<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>好奇心是探索未知世界的钥匙</title>
    <link>https://www.singleye.net/</link>
    <description>Recent content on 好奇心是探索未知世界的钥匙</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Tue, 10 Sep 2024 23:21:33 +0800</lastBuildDate>
    
	<atom:link href="https://www.singleye.net/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>OCR 项目上线了</title>
      <link>https://www.singleye.net/2024/09/ocr-%E9%A1%B9%E7%9B%AE%E4%B8%8A%E7%BA%BF%E4%BA%86/</link>
      <pubDate>Tue, 10 Sep 2024 23:21:33 +0800</pubDate>
      
      <guid>https://www.singleye.net/2024/09/ocr-%E9%A1%B9%E7%9B%AE%E4%B8%8A%E7%BA%BF%E4%BA%86/</guid>
      <description>最近我开发了一个 OCR 系统，并顺便学习了 Nuxt3，写了一个简单的前端页面。经过一番努力，终于将第一个版本成功上线！
目前这个版本的功能：
 文字识别并不稀奇，但目前这个工具尤其擅长识别非常长图 页面上可以查看、选择、编辑识别结果 识别结果还可以进行二次编辑和下载，方便快捷  项目链接奉上，欢迎来体验一下！
https://smartocr.singleye.net
后续还会持续迭代，有建议或需求欢迎给我留言或发邮件。
另外，这次还试用了一个 AI 生成页面的工具：https://v0.dev
通过简单的描述就能自动生成页面，节省了设计和部分代码的工作，对个人开发者来说真是个提高效率的利器！</description>
    </item>
    
    <item>
      <title>SLAM 算法传感器融合方法</title>
      <link>https://www.singleye.net/2024/07/slam-%E7%AE%97%E6%B3%95%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E6%96%B9%E6%B3%95/</link>
      <pubDate>Tue, 16 Jul 2024 14:22:37 +0800</pubDate>
      
      <guid>https://www.singleye.net/2024/07/slam-%E7%AE%97%E6%B3%95%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E6%96%B9%E6%B3%95/</guid>
      <description>&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>欧拉角、旋转矩阵、四元数、轴角相互转换</title>
      <link>https://www.singleye.net/2024/06/%E6%AC%A7%E6%8B%89%E8%A7%92%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5%E5%9B%9B%E5%85%83%E6%95%B0%E8%BD%B4%E8%A7%92%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/</link>
      <pubDate>Sun, 09 Jun 2024 17:01:36 +0800</pubDate>
      
      <guid>https://www.singleye.net/2024/06/%E6%AC%A7%E6%8B%89%E8%A7%92%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5%E5%9B%9B%E5%85%83%E6%95%B0%E8%BD%B4%E8%A7%92%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/</guid>
      <description>&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>基于 Kalman filter 的目标跟踪</title>
      <link>https://www.singleye.net/2024/06/%E5%9F%BA%E4%BA%8E-kalman-filter-%E7%9A%84%E7%9B%AE%E6%A0%87%E8%B7%9F%E8%B8%AA/</link>
      <pubDate>Thu, 06 Jun 2024 09:26:40 +0800</pubDate>
      
      <guid>https://www.singleye.net/2024/06/%E5%9F%BA%E4%BA%8E-kalman-filter-%E7%9A%84%E7%9B%AE%E6%A0%87%E8%B7%9F%E8%B8%AA/</guid>
      <description>&lt;!--toc--&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>在 Apple silicon (M3 Max) 上对 Llama2 进行微调</title>
      <link>https://www.singleye.net/2024/04/%E5%9C%A8-apple-silicon-m3-max-%E4%B8%8A%E5%AF%B9-llama2-%E8%BF%9B%E8%A1%8C%E5%BE%AE%E8%B0%83/</link>
      <pubDate>Fri, 26 Apr 2024 23:48:40 +0800</pubDate>
      
      <guid>https://www.singleye.net/2024/04/%E5%9C%A8-apple-silicon-m3-max-%E4%B8%8A%E5%AF%B9-llama2-%E8%BF%9B%E8%A1%8C%E5%BE%AE%E8%B0%83/</guid>
      <description>&lt;!--toc--&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>tmux AI 助手</title>
      <link>https://www.singleye.net/2024/04/tmux-ai-%E5%8A%A9%E6%89%8B/</link>
      <pubDate>Thu, 04 Apr 2024 17:06:50 +0000</pubDate>
      
      <guid>https://www.singleye.net/2024/04/tmux-ai-%E5%8A%A9%E6%89%8B/</guid>
      <description>日产开发时很喜欢用 tmux，最近写了一个 tmux 的 AI 插件，这个插件可以使用 ollama 支持的 LLM 生成 shell / 编程相关的内容，会对日常使用 CLI 的同学们带来一些帮助。
使用方法：  + Q 调出命令输入栏，在输入栏中写好问题回车，之后 tmux 会把生成的答案在新的窗口中显示出来。
项目链接： https://github.com/singleye/tmux-ai-helper</description>
    </item>
    
    <item>
      <title>使用 ros::waitForShutdown() 导致 dynamic_reconfigure::Server 无法正常获取配置更新的问题</title>
      <link>https://www.singleye.net/2024/03/%E4%BD%BF%E7%94%A8-roswaitforshutdown-%E5%AF%BC%E8%87%B4-dynamic_reconfigureserver-%E6%97%A0%E6%B3%95%E6%AD%A3%E5%B8%B8%E8%8E%B7%E5%8F%96%E9%85%8D%E7%BD%AE%E6%9B%B4%E6%96%B0%E7%9A%84%E9%97%AE%E9%A2%98/</link>
      <pubDate>Sat, 23 Mar 2024 11:43:22 +0800</pubDate>
      
      <guid>https://www.singleye.net/2024/03/%E4%BD%BF%E7%94%A8-roswaitforshutdown-%E5%AF%BC%E8%87%B4-dynamic_reconfigureserver-%E6%97%A0%E6%B3%95%E6%AD%A3%E5%B8%B8%E8%8E%B7%E5%8F%96%E9%85%8D%E7%BD%AE%E6%9B%B4%E6%96%B0%E7%9A%84%E9%97%AE%E9%A2%98/</guid>
      <description>&lt;!--toc--&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>PCL 3D 空间检测平行四边形</title>
      <link>https://www.singleye.net/2023/12/pcl-3d-%E7%A9%BA%E9%97%B4%E6%A3%80%E6%B5%8B%E5%B9%B3%E8%A1%8C%E5%9B%9B%E8%BE%B9%E5%BD%A2/</link>
      <pubDate>Fri, 22 Dec 2023 16:40:06 +0800</pubDate>
      
      <guid>https://www.singleye.net/2023/12/pcl-3d-%E7%A9%BA%E9%97%B4%E6%A3%80%E6%B5%8B%E5%B9%B3%E8%A1%8C%E5%9B%9B%E8%BE%B9%E5%BD%A2/</guid>
      <description>&lt;!--toc--&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>javascript var/let/const 比较</title>
      <link>https://www.singleye.net/2023/12/javascript-var/let/const-%E6%AF%94%E8%BE%83/</link>
      <pubDate>Tue, 12 Dec 2023 23:54:00 +0800</pubDate>
      
      <guid>https://www.singleye.net/2023/12/javascript-var/let/const-%E6%AF%94%E8%BE%83/</guid>
      <description>&lt;!--toc--&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>django-rest-framework 和 simplejwt 的类关系</title>
      <link>https://www.singleye.net/2023/12/django-rest-framework-%E5%92%8C-simplejwt-%E7%9A%84%E7%B1%BB%E5%85%B3%E7%B3%BB/</link>
      <pubDate>Sun, 10 Dec 2023 11:40:29 +0800</pubDate>
      
      <guid>https://www.singleye.net/2023/12/django-rest-framework-%E5%92%8C-simplejwt-%E7%9A%84%E7%B1%BB%E5%85%B3%E7%B3%BB/</guid>
      <description>&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Python 内存管理</title>
      <link>https://www.singleye.net/2023/11/python-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</link>
      <pubDate>Tue, 21 Nov 2023 14:40:28 +0800</pubDate>
      
      <guid>https://www.singleye.net/2023/11/python-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</guid>
      <description>&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>左乘/右乘旋转</title>
      <link>https://www.singleye.net/2023/10/%E5%B7%A6%E4%B9%98/%E5%8F%B3%E4%B9%98%E6%97%8B%E8%BD%AC/</link>
      <pubDate>Wed, 25 Oct 2023 14:38:55 +0800</pubDate>
      
      <guid>https://www.singleye.net/2023/10/%E5%B7%A6%E4%B9%98/%E5%8F%B3%E4%B9%98%E6%97%8B%E8%BD%AC/</guid>
      <description>&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>多媒体格式标准、H264 编码与 MP4 格式简要介绍</title>
      <link>https://www.singleye.net/2023/08/%E5%A4%9A%E5%AA%92%E4%BD%93%E6%A0%BC%E5%BC%8F%E6%A0%87%E5%87%86h264-%E7%BC%96%E7%A0%81%E4%B8%8E-mp4-%E6%A0%BC%E5%BC%8F%E7%AE%80%E8%A6%81%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>Wed, 09 Aug 2023 15:15:25 +0800</pubDate>
      
      <guid>https://www.singleye.net/2023/08/%E5%A4%9A%E5%AA%92%E4%BD%93%E6%A0%BC%E5%BC%8F%E6%A0%87%E5%87%86h264-%E7%BC%96%E7%A0%81%E4%B8%8E-mp4-%E6%A0%BC%E5%BC%8F%E7%AE%80%E8%A6%81%E4%BB%8B%E7%BB%8D/</guid>
      <description>&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>摄像机模型及实现</title>
      <link>https://www.singleye.net/2022/05/%E6%91%84%E5%83%8F%E6%9C%BA%E6%A8%A1%E5%9E%8B%E5%8F%8A%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Sat, 07 May 2022 01:05:50 +0800</pubDate>
      
      <guid>https://www.singleye.net/2022/05/%E6%91%84%E5%83%8F%E6%9C%BA%E6%A8%A1%E5%9E%8B%E5%8F%8A%E5%AE%9E%E7%8E%B0/</guid>
      <description>&lt;!--toc--&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>旋转矩阵</title>
      <link>https://www.singleye.net/2021/01/%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5/</link>
      <pubDate>Thu, 07 Jan 2021 11:40:47 +0800</pubDate>
      
      <guid>https://www.singleye.net/2021/01/%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5/</guid>
      <description>&lt;!--toc--&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>NLP 资源整理</title>
      <link>https://www.singleye.net/2019/09/nlp-%E8%B5%84%E6%BA%90%E6%95%B4%E7%90%86/</link>
      <pubDate>Thu, 19 Sep 2019 12:18:54 +0800</pubDate>
      
      <guid>https://www.singleye.net/2019/09/nlp-%E8%B5%84%E6%BA%90%E6%95%B4%E7%90%86/</guid>
      <description>&lt;!--toc--&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>ssh代理方法</title>
      <link>https://www.singleye.net/2019/09/ssh%E4%BB%A3%E7%90%86%E6%96%B9%E6%B3%95/</link>
      <pubDate>Sun, 01 Sep 2019 15:28:41 +0800</pubDate>
      
      <guid>https://www.singleye.net/2019/09/ssh%E4%BB%A3%E7%90%86%E6%96%B9%E6%B3%95/</guid>
      <description>&lt;!--toc--&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>机器学习笔记 - 贝叶斯分类法推导</title>
      <link>https://www.singleye.net/2019/08/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0---%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E6%B3%95%E6%8E%A8%E5%AF%BC/</link>
      <pubDate>Fri, 09 Aug 2019 10:57:50 +0800</pubDate>
      
      <guid>https://www.singleye.net/2019/08/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0---%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E6%B3%95%E6%8E%A8%E5%AF%BC/</guid>
      <description>&lt;!--toc--&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>VMware ESXi 6.7.0 update2 使用 GPU Passthrough 模式的坑</title>
      <link>https://www.singleye.net/2019/07/vmware-esxi-6.7.0-update2-%E4%BD%BF%E7%94%A8-gpu-passthrough-%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%9D%91/</link>
      <pubDate>Mon, 08 Jul 2019 22:38:07 +0800</pubDate>
      
      <guid>https://www.singleye.net/2019/07/vmware-esxi-6.7.0-update2-%E4%BD%BF%E7%94%A8-gpu-passthrough-%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%9D%91/</guid>
      <description>&lt;!--toc--&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Firefox cache2 数据结构解析</title>
      <link>https://www.singleye.net/2019/06/firefox-cache2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Sun, 30 Jun 2019 23:10:02 +0800</pubDate>
      
      <guid>https://www.singleye.net/2019/06/firefox-cache2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90/</guid>
      <description>&lt;!--toc--&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>哈希计算图片相似性</title>
      <link>https://www.singleye.net/2019/06/%E5%93%88%E5%B8%8C%E8%AE%A1%E7%AE%97%E5%9B%BE%E7%89%87%E7%9B%B8%E4%BC%BC%E6%80%A7/</link>
      <pubDate>Mon, 03 Jun 2019 15:19:04 +0800</pubDate>
      
      <guid>https://www.singleye.net/2019/06/%E5%93%88%E5%B8%8C%E8%AE%A1%E7%AE%97%E5%9B%BE%E7%89%87%E7%9B%B8%E4%BC%BC%E6%80%A7/</guid>
      <description>&lt;!--toc--&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>机器学习 - 决策树</title>
      <link>https://www.singleye.net/2019/04/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0---%E5%86%B3%E7%AD%96%E6%A0%91/</link>
      <pubDate>Mon, 15 Apr 2019 17:04:37 +0800</pubDate>
      
      <guid>https://www.singleye.net/2019/04/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0---%E5%86%B3%E7%AD%96%E6%A0%91/</guid>
      <description>&lt;!--toc--&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>模型评估指标</title>
      <link>https://www.singleye.net/2019/03/%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E6%8C%87%E6%A0%87/</link>
      <pubDate>Thu, 28 Mar 2019 15:49:48 +0800</pubDate>
      
      <guid>https://www.singleye.net/2019/03/%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E6%8C%87%E6%A0%87/</guid>
      <description>&lt;!--toc--&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>机器学习资料收集</title>
      <link>https://www.singleye.net/2019/03/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%E6%94%B6%E9%9B%86/</link>
      <pubDate>Sat, 23 Mar 2019 23:23:28 +0800</pubDate>
      
      <guid>https://www.singleye.net/2019/03/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%E6%94%B6%E9%9B%86/</guid>
      <description>&lt;!--toc--&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>阿里ECS服务器使用腾讯企业邮箱发送SMTP邮件的问题</title>
      <link>https://www.singleye.net/2019/01/%E9%98%BF%E9%87%8Cecs%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BD%BF%E7%94%A8%E8%85%BE%E8%AE%AF%E4%BC%81%E4%B8%9A%E9%82%AE%E7%AE%B1%E5%8F%91%E9%80%81smtp%E9%82%AE%E4%BB%B6%E7%9A%84%E9%97%AE%E9%A2%98/</link>
      <pubDate>Sat, 19 Jan 2019 00:39:37 +0800</pubDate>
      
      <guid>https://www.singleye.net/2019/01/%E9%98%BF%E9%87%8Cecs%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BD%BF%E7%94%A8%E8%85%BE%E8%AE%AF%E4%BC%81%E4%B8%9A%E9%82%AE%E7%AE%B1%E5%8F%91%E9%80%81smtp%E9%82%AE%E4%BB%B6%E7%9A%84%E9%97%AE%E9%A2%98/</guid>
      <description>在阿里ECS上搭建的服务需要使用腾讯企业邮箱发送团队邮件，结果发现使用腾讯官方SMTP服务器配置方法无法发送成功，最后发现需要使用 587 端口才可以，这一点在官方文档里根本看不到，真是不得不吐槽啊！
正确的SMTP配置是： smtp.exmail.qq.com:587
另外需要注意的一点，如果需要使用外部的25端口上的SMTP服务器时需要向ECS申请开通才行，默认情况下ECS会屏蔽25端口出方向的流量。</description>
    </item>
    
    <item>
      <title>解决flask_restful无法对Decimal类型数据进行序列化问题</title>
      <link>https://www.singleye.net/2019/01/%E8%A7%A3%E5%86%B3flask_restful%E6%97%A0%E6%B3%95%E5%AF%B9decimal%E7%B1%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E8%BF%9B%E8%A1%8C%E5%BA%8F%E5%88%97%E5%8C%96%E9%97%AE%E9%A2%98/</link>
      <pubDate>Wed, 16 Jan 2019 12:27:13 +0800</pubDate>
      
      <guid>https://www.singleye.net/2019/01/%E8%A7%A3%E5%86%B3flask_restful%E6%97%A0%E6%B3%95%E5%AF%B9decimal%E7%B1%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E8%BF%9B%E8%A1%8C%E5%BA%8F%E5%88%97%E5%8C%96%E9%97%AE%E9%A2%98/</guid>
      <description>&lt;!--toc--&gt;

&lt;p&gt;在使用flask进行开发的时候发现 &lt;strong&gt;Decimal&lt;/strong&gt; 类型的数据无法在作为 JSON 通过相应消息体序列化返回，出现 &lt;strong&gt;jsonschema.exceptions.ValidationError&lt;/strong&gt; 错误：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;jsonschema.exceptions.ValidationError: &#39;1000.00&#39; is not of type &#39;number&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Build Tensorflow v1.7 on NVIDIA Jetson tx2</title>
      <link>https://www.singleye.net/2018/04/build-tensorflow-v1.7-on-nvidia-jetson-tx2/</link>
      <pubDate>Thu, 12 Apr 2018 11:06:51 +0800</pubDate>
      
      <guid>https://www.singleye.net/2018/04/build-tensorflow-v1.7-on-nvidia-jetson-tx2/</guid>
      <description>&lt;!--toc--&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>说一说反弹shell</title>
      <link>https://www.singleye.net/2018/04/%E8%AF%B4%E4%B8%80%E8%AF%B4%E5%8F%8D%E5%BC%B9shell/</link>
      <pubDate>Mon, 09 Apr 2018 23:59:32 +0800</pubDate>
      
      <guid>https://www.singleye.net/2018/04/%E8%AF%B4%E4%B8%80%E8%AF%B4%E5%8F%8D%E5%BC%B9shell/</guid>
      <description>&lt;!--toc--&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>使用Python的Selenium驱动浏览器行为</title>
      <link>https://www.singleye.net/2018/03/%E4%BD%BF%E7%94%A8python%E7%9A%84selenium%E9%A9%B1%E5%8A%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E8%A1%8C%E4%B8%BA/</link>
      <pubDate>Fri, 30 Mar 2018 11:25:39 +0800</pubDate>
      
      <guid>https://www.singleye.net/2018/03/%E4%BD%BF%E7%94%A8python%E7%9A%84selenium%E9%A9%B1%E5%8A%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E8%A1%8C%E4%B8%BA/</guid>
      <description>&lt;!--toc--&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>自动饮水机</title>
      <link>https://www.singleye.net/2018/03/%E8%87%AA%E5%8A%A8%E9%A5%AE%E6%B0%B4%E6%9C%BA/</link>
      <pubDate>Tue, 20 Mar 2018 16:42:45 +0800</pubDate>
      
      <guid>https://www.singleye.net/2018/03/%E8%87%AA%E5%8A%A8%E9%A5%AE%E6%B0%B4%E6%9C%BA/</guid>
      <description>Youtube观看：
  Youku观看:
  </description>
    </item>
    
    <item>
      <title>使用Nvidia Jetson TX2挖以太币</title>
      <link>https://www.singleye.net/2018/03/%E4%BD%BF%E7%94%A8nvidia-jetson-tx2%E6%8C%96%E4%BB%A5%E5%A4%AA%E5%B8%81/</link>
      <pubDate>Sun, 11 Mar 2018 10:34:02 +0800</pubDate>
      
      <guid>https://www.singleye.net/2018/03/%E4%BD%BF%E7%94%A8nvidia-jetson-tx2%E6%8C%96%E4%BB%A5%E5%A4%AA%E5%B8%81/</guid>
      <description>现在加密货币在全世界都到了很疯狂的程度了，经常听说挖矿，那么挖矿究竟是怎么回事呢，到底怎么进行挖矿呢？这里介绍一下以太币挖矿的那些事儿。
进行挖矿大概需要几个步骤：
 注册钱包 加入矿池 准备挖矿工具 开挖  下面详细介绍一下如何进行挖矿。
获取以太币钱包地址 使用myetherwallet 挖矿前首先需要创建自己的钱包，可以到“myetherwallet”(https://www.myetherwallet.com)进行创建。
第一步：输入密码，点击“Create New Wallet”： 第二步：保存&amp;rdquo;Keystore&amp;rdquo;密钥，密钥文件一定要小心保存，如果丢失了那么钱包就永远也找不回来了。另外最好使用物理隔离，可以存在U盘上需要用的时候再拿出来，或者干脆打印出来，如果密码被盗窃那所有的以太币就不保了 :P
之后为了方便管理可以使用chrome浏览器的&amp;rdquo;&amp;ldquo;插件进行创建。
使用MetaMask 还有一个更方便的创建钱包的方法，就是使用chrome浏览器的&amp;rdquo;MetaMask&amp;rdquo;插件进行创建和管理。 需要提醒一下，创建成功后一定要保护好创建钱包的那12个单词，这是唯一的恢复账号的方法！
使用&amp;rdquo;MetaMask&amp;rdquo;跟myetherwallet不太一样的一点是，在创建出钱包的密钥是通过&amp;rdquo;MetaMask&amp;rdquo;进行管理的，这种方法有好有坏，好处是使用方便，坏处是一旦MetaMask挂了或者被黑的话，那么你的钱包也会受到牵连。
选择矿池 有了钱包地址后需要加入矿池才有资格成为一名真正的矿工，截止2018-03-11，全世界的矿池总算力已经达到了259.27 TH/s
（数据来自Top Miners）
国内用户可以选择国内的矿池：
   矿池 地址 矿池 起付点 费率     f2pool https://www.f2pool.com eth.f2pool.com:8008eth.f2pool.com:8080 0.1 ETH 3%   ethfans https://eth.ethfans.org/#/ huabei-pool.ethfans.org:3333huabei-pool.ethfans.org:13333guangdong-pool.ethfans.org:3333guangdong-pool.ethfans.org:13333 0.05 ETH 1%    选择挖矿软件 现在开好户签好合同了，矿工要开始干活了 :-)
家里唯一有个靠谱GPU的机器就是我的小Jetson了，之前学习机器学习时候买的小平台，这下要从码农变身矿工了。
常用的挖矿软件有两个：
   软件 CPU GPU CUDA OpenCL     ethminer No Yes, ver &amp;gt; 9.</description>
    </item>
    
    <item>
      <title>python2 和 python3 的一些区别</title>
      <link>https://www.singleye.net/2018/02/python2-%E5%92%8C-python3-%E7%9A%84%E4%B8%80%E4%BA%9B%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Mon, 26 Feb 2018 23:30:06 +0800</pubDate>
      
      <guid>https://www.singleye.net/2018/02/python2-%E5%92%8C-python3-%E7%9A%84%E4%B8%80%E4%BA%9B%E5%8C%BA%E5%88%AB/</guid>
      <description> python2与python3的区别    区别点 python2 python3     write() 可以直接写utf8内容 写utf8内容碰到：TypeError: write() argument must be str, not bytes解决方法：open(file, &amp;lsquo;wb&amp;rsquo;)   super() super(CLASS_NAME, self).method() super().method()   / 除法运算，结果取整数 除法运算，结果为浮点数，取证书使用“//”   dict has_key()可以用来查询是否存在某个键 has_key()方法不存了，使用&amp;rsquo;key in dictionary&amp;rsquo;来查询(python2也支持该方法)    python3的新特性    新特性 描述 参考     @ 矩阵乘法运算符，目前还没有定义built-in的矩阵数据类型 PEP 465 - A dedicated infix operator for matrix multiplication   / 除法运算，结果浮点数    // 除法运算，结果取整数     </description>
    </item>
    
    <item>
      <title>Mysql charset/collation字符编码设置</title>
      <link>https://www.singleye.net/2018/01/mysql-charset/collation%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E8%AE%BE%E7%BD%AE/</link>
      <pubDate>Tue, 23 Jan 2018 11:20:33 +0800</pubDate>
      
      <guid>https://www.singleye.net/2018/01/mysql-charset/collation%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E8%AE%BE%E7%BD%AE/</guid>
      <description>mysql在创建数据库时有两个跟字符编码相关的参数&amp;rdquo;character set&amp;rdquo;和&amp;rdquo;collate&amp;rdquo;，这里解释一下这两个参数的作用。
character set “character set”很容易解释，就是指定字符在存储到mysql中时使用的编码集。数据库支持哪些编码可以通过&amp;rdquo;show character set&amp;rdquo;获得。
 mysql show character set; +----------+-----------------------------+---------------------+--------+ | Charset | Description | Default collation | Maxlen | +----------+-----------------------------+---------------------+--------+ | big5 | Big5 Traditional Chinese | big5_chinese_ci | 2 | | dec8 | DEC West European | dec8_swedish_ci | 1 | | cp850 | DOS West European | cp850_general_ci | 1 | | hp8 | HP West European | hp8_english_ci | 1 | | koi8r | KOI8-R Relcom Russian | koi8r_general_ci | 1 | | latin1 | cp1252 West European | latin1_swedish_ci | 1 | | latin2 | ISO 8859-2 Central European | latin2_general_ci | 1 | | swe7 | 7bit Swedish | swe7_swedish_ci | 1 | | ascii | US ASCII | ascii_general_ci | 1 | | ujis | EUC-JP Japanese | ujis_japanese_ci | 3 | | sjis | Shift-JIS Japanese | sjis_japanese_ci | 2 | | hebrew | ISO 8859-8 Hebrew | hebrew_general_ci | 1 | | tis620 | TIS620 Thai | tis620_thai_ci | 1 | | euckr | EUC-KR Korean | euckr_korean_ci | 2 | | koi8u | KOI8-U Ukrainian | koi8u_general_ci | 1 | | gb2312 | GB2312 Simplified Chinese | gb2312_chinese_ci | 2 | | greek | ISO 8859-7 Greek | greek_general_ci | 1 | | cp1250 | Windows Central European | cp1250_general_ci | 1 | | gbk | GBK Simplified Chinese | gbk_chinese_ci | 2 | | latin5 | ISO 8859-9 Turkish | latin5_turkish_ci | 1 | | armscii8 | ARMSCII-8 Armenian | armscii8_general_ci | 1 | | utf8 | UTF-8 Unicode | utf8_general_ci | 3 | | ucs2 | UCS-2 Unicode | ucs2_general_ci | 2 | | cp866 | DOS Russian | cp866_general_ci | 1 | | keybcs2 | DOS Kamenicky Czech-Slovak | keybcs2_general_ci | 1 | | macce | Mac Central European | macce_general_ci | 1 | | macroman | Mac West European | macroman_general_ci | 1 | | cp852 | DOS Central European | cp852_general_ci | 1 | | latin7 | ISO 8859-13 Baltic | latin7_general_ci | 1 | | utf8mb4 | UTF-8 Unicode | utf8mb4_general_ci | 4 | | cp1251 | Windows Cyrillic | cp1251_general_ci | 1 | | utf16 | UTF-16 Unicode | utf16_general_ci | 4 | | utf16le | UTF-16LE Unicode | utf16le_general_ci | 4 | | cp1256 | Windows Arabic | cp1256_general_ci | 1 | | cp1257 | Windows Baltic | cp1257_general_ci | 1 | | utf32 | UTF-32 Unicode | utf32_general_ci | 4 | | binary | Binary pseudo charset | binary | 1 | | geostd8 | GEOSTD8 Georgian | geostd8_general_ci | 1 | | cp932 | SJIS for Windows Japanese | cp932_japanese_ci | 2 | | eucjpms | UJIS for Windows Japanese | eucjpms_japanese_ci | 3 | +----------+-----------------------------+---------------------+--------+ 40 rows in set (0.</description>
    </item>
    
    <item>
      <title>在区块链上存储信息</title>
      <link>https://www.singleye.net/2018/01/%E5%9C%A8%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%8A%E5%AD%98%E5%82%A8%E4%BF%A1%E6%81%AF/</link>
      <pubDate>Sat, 13 Jan 2018 09:30:01 +0800</pubDate>
      
      <guid>https://www.singleye.net/2018/01/%E5%9C%A8%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%8A%E5%AD%98%E5%82%A8%E4%BF%A1%E6%81%AF/</guid>
      <description>区块链本质上讲是一个分布式存储，目前流行的比特币/以太坊主要用来存储交易数据，那么是否可以利用这些公链存储别的信息呢？
当然是有的，收集了几篇关于如何使用区块链存储数据文章，回头有空了再来整理一下。
 http://www.righto.com/2014/02/ascii-bernanke-wikileaks-photographs.html https://bitcoin.stackexchange.com/questions/39347/how-to-store-data-on-the-blockchain https://ethereum.stackexchange.com/questions/7884/how-can-i-store-data-in-ethereum-blockchain https://docs.google.com/document/d/1UwaaUgunnrFpL6jetA_DdNLQsbbqBx1HLcln07kLrUw/edit  </description>
    </item>
    
    <item>
      <title>Spark开发</title>
      <link>https://www.singleye.net/2018/01/spark%E5%BC%80%E5%8F%91/</link>
      <pubDate>Thu, 11 Jan 2018 23:10:50 +0800</pubDate>
      
      <guid>https://www.singleye.net/2018/01/spark%E5%BC%80%E5%8F%91/</guid>
      <description>使用scala进行开发 Step1: 安装sbt  $ curl https://bintray.com/sbt/rpm/rpm | sudo tee /etc/yum.repos.d/bintray-sbt-rpm.repo $ sudo yum install sbt  配置源：
 # cat ~/.sbt/repositories [repositories] # 本地源 local # 阿里源 aliyun: http://maven.aliyun.com/nexus/content/groups/public/ typesafe: http://repo.typesafe.com/typesafe/ivy-releases/, [organization]/[module]/(scala_[scalaVersion]/)(sbt_[sbtVersion]/)[revision]/[type]s/[artifact](-[classifier]).[ext], bootOnly sonatype-oss-releases maven-central sonatype-oss-snapshots  Step2: 创建项目 可以使用Giter8模版创建项目。
 $ sbt new imarios/frameless.g8  spark相关的几个模版：
 holdenk/sparkProjectTemplate.g8 (Template for Scala Apache Spark project). imarios/frameless.g8 (A simple frameless template to start with more expressive types for Spark) nttdata-oss/basic-spark-project.</description>
    </item>
    
    <item>
      <title>Hive Intro</title>
      <link>https://www.singleye.net/2018/01/hive-intro/</link>
      <pubDate>Thu, 11 Jan 2018 22:25:07 +0800</pubDate>
      
      <guid>https://www.singleye.net/2018/01/hive-intro/</guid>
      <description> Reference * Hive document </description>
    </item>
    
    <item>
      <title>Hcatalog简介</title>
      <link>https://www.singleye.net/2018/01/hcatalog%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Thu, 11 Jan 2018 19:51:16 +0800</pubDate>
      
      <guid>https://www.singleye.net/2018/01/hcatalog%E7%AE%80%E4%BB%8B/</guid>
      <description>HCatalog是Hadoop生态链中的一个有趣的组件。HCatalog构建于Hive的metastore之上并结合了Hive的DDL，通过服务的形式开放给Hadoop生态链中的其他组件，这样即可用一种统一的形式将Hive数据仓库中的数据的metadata开放给需要的服务，这样的话需要的服务就可以通过HCatalog来了解到所使用的数据的内容以及格式等等元信息。
下图展示了HCatalog在Hadoop生态系统中的定位：
可以看出HCatalog内置可以支持多种数据格式：
 ORC RC Text SequenceFile  另外用户还可以自定义格式，不过需要编写InputFormat, OutputFormat, SerDe(Serializer/Deserializer):
HCatalog提供了&amp;rsquo;hcat&amp;rsquo;
 $ hcat usage: hcat { -e &#34;&#34; | -f &#34;&#34; } [ -g &#34;&#34; ] [ -p &#34;&#34; ] [ -D&#34;=&#34; ] -D  use hadoop value for given property -e  hcat command given from command line -f  hcat commands in file -g  group for the db/table specified in CREATE statement -h,--help Print help information -p  permissions for the db/table specified in CREATE statement  参数-e提供了使用Hive &amp;lsquo;DDL&amp;rsquo;命令的接口</description>
    </item>
    
    <item>
      <title>Yarn Config</title>
      <link>https://www.singleye.net/2017/12/yarn-config/</link>
      <pubDate>Fri, 29 Dec 2017 11:44:51 +0800</pubDate>
      
      <guid>https://www.singleye.net/2017/12/yarn-config/</guid>
      <description>Resource manager Node manager Application master
 资源
 Container
 container所需资源，minimum/maximum memory/vcores  Scheduler
 FIFO CapacityScheduler FairScheduler  Queue
  Application &amp;mdash; scheduler &amp;mdash;&amp;gt; Queue
yarn-site.xml中配置。
下文引用自http://dongxicheng.org/mapreduce-nextgen/hadoop-yarn-configurations-resourcemanager-nodemanager/
Node manager Node manager architecture
ResourceManager相关配置参数  （1） yarn.resourcemanager.address  参数解释：ResourceManager 对客户端暴露的地址。客户端通过该地址向RM提交应用程序，杀死应用程序等。
默认值：${yarn.resourcemanager.hostname}:8032
 （2） yarn.resourcemanager.scheduler.address  参数解释：ResourceManager 对ApplicationMaster暴露的访问地址。ApplicationMaster通过该地址向RM申请资源、释放资源等。
默认值：${yarn.resourcemanager.hostname}:8030
 （3） yarn.resourcemanager.resource-tracker.address 参数解释：ResourceManager 对NodeManager暴露的地址.。NodeManager通过该地址向RM汇报心跳，领取任务等。 默认值：${yarn.resourcemanager.hostname}:8031
 （4） yarn.resourcemanager.admin.address
  参数解释：ResourceManager 对管理员暴露的访问地址。管理员通过该地址向RM发送管理命令等。
默认值：${yarn.resourcemanager.hostname}:8033
 （5） yarn.resourcemanager.webapp.address  参数解释：ResourceManager对外web ui地址。用户可通过该地址在浏览器中查看集群各类信息。</description>
    </item>
    
    <item>
      <title>Sqoop介绍及使用</title>
      <link>https://www.singleye.net/2017/12/sqoop%E4%BB%8B%E7%BB%8D%E5%8F%8A%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Mon, 25 Dec 2017 18:11:29 +0800</pubDate>
      
      <guid>https://www.singleye.net/2017/12/sqoop%E4%BB%8B%E7%BB%8D%E5%8F%8A%E4%BD%BF%E7%94%A8/</guid>
      <description>1. HDP中使用sqoop进行工作流处理准备工作 1.1 准备hdfs中的用户目录  在进行hdfs操作前需要切换用户到&amp;rsquo;hdfs&amp;rsquo;
# su - hdfs  为操作用户创建hdfs环境
  此处为ambari的admin用户准备环境：
 $ hdfs dfs -mkdir /user/admin $ hdfs dfs -chown admin:hdfs /user/admin $ hdfs dfs -ls /user $ hdfs dfs -chmod -R 770 /user/admin  1.2 配置ozzie  设置ozzie进程在hdfs中的proxy user
配置项：hadoop.proxyuser.oozie.groups 值：$USER_GROUPS_THAT_ALLOW_IMPERSONATION 配置项: hadoop.proxyuser.oozie.hosts 值：$OOZIE_SERVER_HOSTNAME   PS. 代理机制 ：http://dongxicheng.org/mapreduce-nextgen/hadoop-secure-impersonation/
主备namenode和resoucemanager（hadoop 2.0）上的core-site.xml中增加以下配置:
 &amp;lt;property&amp;gt; &amp;lt;name&amp;gt;hadoop.proxyuser.oozie.groups&amp;lt;/name&amp;gt; &amp;lt;value&amp;gt;group1,group2&amp;lt;value&amp;gt; &amp;lt;/property&amp;gt; &amp;lt;property&amp;gt; &amp;lt;name&amp;gt;hadoop.proxyuser.oozie.hosts&amp;lt;/name&amp;gt; &amp;lt;value&amp;gt;host1,host2&amp;lt;value&amp;gt; &amp;lt;/property&amp;gt;  这里，假设用户user1属于group1（注意，这里的user1和group1都是linux用户和用户组，需要在namenode和jobtracker上进行添加），此外，为了限制客户端随意部署，超级用户代理功能只支持host1和host2两个节点。经过以上配置后，在host1和host2上的客户端上，属于group1和group2的用户可以sudo成oozie用户，执行作业流。
 拷贝mysql-connector及配置  切换到oozie用户后执行：</description>
    </item>
    
    <item>
      <title>Nginx Static</title>
      <link>https://www.singleye.net/2017/12/nginx-static/</link>
      <pubDate>Sat, 23 Dec 2017 19:41:39 +0800</pubDate>
      
      <guid>https://www.singleye.net/2017/12/nginx-static/</guid>
      <description>nginx配置静态文件服务器
搭建文件服务器 要点就是root目录,会自动指向索引文件 如： index, index.html等
server { client_max_body_size 4G; listen 80; ## listen for ipv4; this line is default and implied server_name static.test.sdk.iwplay.com.tw; root /home/mini/Sync; location / { } }  建立索引 建立目录索引也同样如此，不要带索引名称之类的文件，否则会直接显示文件，而不是目录
server { client_max_body_size 4G; listen 80; ## listen for ipv4; this line is default and implied server_name static.test.sdk.iwplay.com.tw; root /home/mini/Sync; location / { autoindex on; //显示索引 autoindex_exact_size on; //显示大小 autoindex_localtime on; //显示时间 } }  设置密码 搭建文件服务器有时候不想让别人任意访问，想做成一个私有的该怎么办呢，这个时候我们可以用到nginx自带的认证模块。 同样关键的是auth_basic/auth_basic_user_file字段</description>
    </item>
    
    <item>
      <title>Horwonworks HDP 2.6安装过程</title>
      <link>https://www.singleye.net/2017/12/horwonworks-hdp-2.6%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B/</link>
      <pubDate>Sat, 23 Dec 2017 15:38:37 +0800</pubDate>
      
      <guid>https://www.singleye.net/2017/12/horwonworks-hdp-2.6%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B/</guid>
      <description> 安装ambari-server # yum install ambari-server  配置ambari cluster # ambari-server setup # ambari-server start  配置cluster 步骤1:
将clsuter中的所有node设置成ssh免密码登录了的方式。
步骤2:
访问 http://&amp;lt;ambari-server&amp;gt;:8080
步骤3:
设置cluster名称
步骤4:
配置安装源，可以使用私有源：
HDP私有源：
http://hdp-repo.iwaterdata.com:7300/HDP/centos7/2.x/updates/2.6.3.0  HDP-UTILS私有源：
http://hdp-repo.iwaterdata.com:7300/HDP-UTILS-1.1.0.21/repos/centos7  步骤5:
安装程序检查配置节点
步骤6:
选择安装软件列表
步骤7:
设置各软件的配置信息
步骤8:
安装完成后程序会尝试启动各服务，有可能启动会失败（比如内存不足无法启动所有程序），只要确定程序正确安装可以继续
misc 设置JDBC driver(Customize service中 oozie需要)
# ambari-server setup --jdbc-db=mysql --jdbc-driver=/usr/share/java/mysql-connector-java.jar  </description>
    </item>
    
    <item>
      <title>golang UDP中Read()/ReadFromUDP()/Write()/WriteToUDP()的使用</title>
      <link>https://www.singleye.net/2017/12/golang-udp%E4%B8%ADread/readfromudp/write/writetoudp%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Tue, 05 Dec 2017 15:19:40 +0800</pubDate>
      
      <guid>https://www.singleye.net/2017/12/golang-udp%E4%B8%ADread/readfromudp/write/writetoudp%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
      <description>学习golang进行UDP client/server通讯的过程中发现Read/ReadFromUDP/Write/WriteToUDP的使用有些需要注意之处，这里记录一下。
代码实验 UDP server UDP服务器端在调用&amp;rdquo;net.ListenUDP()&amp;ldquo;后创建&amp;rdquo;net.UDPConn&amp;rdquo;，read/write操作是通过这个UDPConn来完成的。因为listen的时候只指定了本地绑定的地址，它只能被动的接收来自客户端的消息，因此这个UDPConn在golang中为&amp;rsquo;unconnected&amp;rsquo;类型的。
这种类型的UDPConn的读操作可以接受Read()及ReadFromUDP()。区别是Read()无法知道远程连接的地址信息而ReadFromUDP()可以，所以如果后续需要跟远程进行双向通讯需要使用ReadFromUDP()。
这种类型的UDPConn在进行写操作时必须使用WriteToUDP()完成，并且需要指定对方的地址信息。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48  package main import ( &amp;#34;flag&amp;#34; &amp;#34;fmt&amp;#34; &amp;#34;net&amp;#34; &amp;#34;os&amp;#34; ) var host = flag.</description>
    </item>
    
    <item>
      <title>GO语言依赖管理那些事儿</title>
      <link>https://www.singleye.net/2017/12/go%E8%AF%AD%E8%A8%80%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/</link>
      <pubDate>Sat, 02 Dec 2017 18:17:23 +0800</pubDate>
      
      <guid>https://www.singleye.net/2017/12/go%E8%AF%AD%E8%A8%80%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/</guid>
      <description>学习GO开发的过程中发现GO的依赖管理有些不够合理之处。
首先，使用GO开发时在假设项目及依赖关系都通过全系统唯一的GOPATH进行管理，可事实上一个开发人员不可能同时只做一个项目开发，不能假设不同项目的依赖都是一致的。这个问题自从v1.5引入vendor管理方法得到了一定改善。可是go get对vendor支持并不友好，这增加了管理的工作量。很多项目也被开发出来解决这个问题，比如&amp;rsquo;govendor&amp;rsquo;。
引入vendor方法后的项目依赖查找顺序如下：
 首先查找当前包下面的vendor目录 向上一级目录查找，直至找到src目录下的vendor目录 在GOPATH下面查找 在GOROOT下面查找  第二个不合理的地方，虽然引入了vendor目录解决单独项目的局部依赖管理问题，但依然要求把每个项目放入系统全局GOPATH中进行管理。可是一个项目可能只是一个大项目中的一小部分，而整个大项目可能有不同的开发语言构成，那么管理这种混合项目就是一个很麻烦的事情。另外每一个项目本身随着开发时间的推移会出现多个版本，当你在处理一个版本的问题是可能需要临时切换到另一个版本，基于同一个GOPATH目录开发时对于这种切换管理也并不算友好。&amp;rsquo;gb&amp;rsquo;这个项目开发出来后解决了这一问题，但这导致了项目管理必须使用gb工具，就连基本的build也脱离不开这种依赖，这也导致了本人碰到的第三个问题。
第三个不合理之处是对于编辑器的不友好。由于个人的主要编辑器是vim，并且使用了vim-go插件，这个插件支持了Go的开发工具链，可以在vim中方便的使用GoFmt/GoImports/GoBuild/GoTest等这些命令进行开发。但是由于gb对vim的支持欠缺导致在gb创建的项目若不放入标准的GOPATH中有些vim-go的命令执行会出现问题。</description>
    </item>
    
    <item>
      <title>Beego开发入门</title>
      <link>https://www.singleye.net/2017/11/beego%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/</link>
      <pubDate>Thu, 30 Nov 2017 18:04:31 +0800</pubDate>
      
      <guid>https://www.singleye.net/2017/11/beego%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/</guid>
      <description>安装  安装beego：  $ go get github.com/astaxie/beego  安装bee开发工具：  $ go get github.com/beego/bee $ bee Bee is a Fast and Flexible tool for managing your Beego Web Application. USAGE bee command [arguments] AVAILABLE COMMANDS version Prints the current Bee version migrate Runs database migrations api Creates a Beego API application bale Transforms non-Go files to Go source files fix Fixes your application by making it compatible with newer versions of Beego dlv Start a debugging session using Delve dockerize Generates a Dockerfile for your Beego application generate Source code generator hprose Creates an RPC application based on Hprose and Beego frameworks new Creates a Beego application pack Compresses a Beego application into a single file rs Run customized scripts run Run the application by starting a local development server server serving static content over HTTP on port Use bee help [command] for more information about a command.</description>
    </item>
    
    <item>
      <title>Git Submodule使用方法</title>
      <link>https://www.singleye.net/2017/11/git-submodule%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</link>
      <pubDate>Fri, 24 Nov 2017 15:49:02 +0800</pubDate>
      
      <guid>https://www.singleye.net/2017/11/git-submodule%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</guid>
      <description>假设有两个项目project1和project2代码仓库：
$ ls project1/ HEAD branches config description hooks info objects refs $ ls project2/ HEAD branches config description hooks info objects refs 1. 从代码仓库clone开发库p1/p2 $git clone ../project1 p1 Cloning into &amp;#39;p1&amp;#39;... warning: You appear to have cloned an empty repository. done. $ git clone ../project2 p2 Cloning into &amp;#39;p2&amp;#39;... warning: You appear to have cloned an empty repository. done. 2. 对p1/p2做一些改动并且push到原代码仓库 在p1中添加新文件file1并且push到远程库project1
$ touch file1 $ git add file1 $ git commit [master (root-commit) 9132026] Init project 1 with file1 1 file changed, 0 insertions(+), 0 deletions(-) create mode 100644 file1 在p2中添加新文件file2并且push到远程库project2</description>
    </item>
    
    <item>
      <title>Vim 8 Mac</title>
      <link>https://www.singleye.net/2017/11/vim-8-mac/</link>
      <pubDate>Mon, 20 Nov 2017 00:08:15 +0800</pubDate>
      
      <guid>https://www.singleye.net/2017/11/vim-8-mac/</guid>
      <description>安装vim8 $ xcode-select --install $ ./configure --enable-luainterp=yes --enable-perlinterp=yes --enable-pythoninterp=yes --enable-tclinterp=yes --enable-rubyinterp=yes --enable-cscope --with-lua-prefix=/usr/local --enable-terminal --enable-multibyte --with-features=huge $ make $ make install  安装插件 安装YouCompleteMe: $ ./install.py --clang-completer --go-completer --js-completer  vim folding    命令 功能     za 打开/关闭当前的折叠   zc 关闭当前打开的折叠   zo 打开当前的折叠   zm 关闭所有折叠   zM 关闭所有折叠及其嵌套的折叠   zr 打开所有折叠   zR 打开所有折叠及其嵌套的折叠   zd 删除当前折叠   zE 删除所有折叠   zj 移动至下一个折叠   zk 移动至上一个折叠   zn 禁用折叠   zN 启用折叠    Issues macos iTerm启动vim后第一行显示&amp;rsquo;$p&amp;rsquo;字符 解决方法：把终端类型从xterm或者xterm-256color改为linux</description>
    </item>
    
    <item>
      <title>Hyperledger Intro</title>
      <link>https://www.singleye.net/2017/11/hyperledger-intro/</link>
      <pubDate>Thu, 16 Nov 2017 17:23:21 +0800</pubDate>
      
      <guid>https://www.singleye.net/2017/11/hyperledger-intro/</guid>
      <description>Hyperledger项目：
 Hyperledger Fabric Hyperledger Sawtooth Hyperledger Composer  模型：
 Assets(资产)  一般定义方式：
 /** * A vehicle asset. */ asset Vehicle identified by vin { o String vin }  继承方式：
 /** * A car asset. A car is related to a list of parts */ asset Car extends Vehicle { o String model --&amp;gt; Part[] Parts }  抽象方式：
 /** * An abstract Vehicle asset. */ abstract asset Vehicle identified by vin { o String vin }   Participants(参与者)</description>
    </item>
    
    <item>
      <title>Django静态文件配置</title>
      <link>https://www.singleye.net/2017/11/django%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Thu, 16 Nov 2017 16:23:13 +0800</pubDate>
      
      <guid>https://www.singleye.net/2017/11/django%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6%E9%85%8D%E7%BD%AE/</guid>
      <description>配置项：
   配置项 说明 例子     STATIC_URL 用户通过web访问静态文件时的URL前缀部分 STATIC_URL=&amp;ldquo;/static/&amp;rdquo;   STATIC_ROOT manager.py collectstatic执行后静态文件会收集存放到 STATIC_ROOT = os.path.join(BASE_DIR, &amp;lsquo;collected_static&amp;rsquo;)   STATICFILES_DIRS 每个app目录中可以创建一个static目录存放对应的静态文件，也可以通过在settings文件中指定STATICFILES_DIRS来指定一个公共的位置存放静态文件 
STATICFILES_DIRS = ( os.path.join(BASE_DIR, &amp;ldquo;common_static&amp;rdquo;), &amp;lsquo;/path/to/others/static/&amp;rsquo;, # 指定一个目录)   STATICFILES_FINDERS 指定静态文件查找器 STATICFILES_FINDERS = ( &amp;ldquo;django.contrib.staticfiles.finders.FileSystemFinder&amp;rdquo;, &amp;ldquo;django.contrib.staticfiles.finders.AppDirectoriesFinder&amp;rdquo;)   DEBUG 如果指定&amp;rsquo;DEBUG=True&amp;rsquo;，那么Django通过STATICFILES_FINDERS指定的查找器寻找静态文件。如果指定&amp;rsquo;DEBUG=False&amp;rsquo;，那么Django不会负责静态文件访问服务，这时可以通过apache或者nginx提供静态文件服务，访问前一般通过&amp;rsquo;collectstatic&amp;rsquo;把项目静态文件收集好后统一部署。     </description>
    </item>
    
    <item>
      <title>Go语言编程陷阱</title>
      <link>https://www.singleye.net/2017/11/go%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B%E9%99%B7%E9%98%B1/</link>
      <pubDate>Tue, 14 Nov 2017 00:55:51 +0800</pubDate>
      
      <guid>https://www.singleye.net/2017/11/go%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B%E9%99%B7%E9%98%B1/</guid>
      <description>陷阱1: &amp;ldquo;is pointer to interface, not interface&amp;rdquo; 执行下面代码会出现&amp;rdquo;type *net.Conn is pointer to interface, not interface)&amp;ldquo;错误，原因是因为&amp;rdquo;net.Conn&amp;rdquo;是interface而不是struct，不能用指针方式传递。
1 2 3 4 5 6 7 8 9  func connHandler(client *net.Conn) { // do something 	} func somefunc() { // ... 	client, _ := listener.Accept() connHandler(&amp;amp;client) }   GO语言中interface是一种特殊的数据结构，包含两部分内容：
 一个指向方法表的指针 一个指向实际数据的指针  因为这种特殊的数据结构所以interface的指针指向的结构既没有实际数据也没有对应方法，那么就无法直接访问所需的内容，鉴于此原因我推测GO语言的开发者直接屏蔽掉了指向interface指针的用法。这种情况的正确如下：
1 2 3 4 5 6 7 8 9  func connHandler(client net.Conn) { // do something 	} func somefunc() { // .</description>
    </item>
    
    <item>
      <title>GO开发技巧</title>
      <link>https://www.singleye.net/2017/11/go%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/</link>
      <pubDate>Fri, 10 Nov 2017 20:37:07 +0800</pubDate>
      
      <guid>https://www.singleye.net/2017/11/go%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/</guid>
      <description>1. 设置GO语言vim开发环境 在vim中开发GO最好安装相关的插件，比如vim-go这个插件。这个插件除了提供格式化、语法高亮、语法检测等功能以外还有很多方便的功能。
编译命令，对应go build：
:GoBuild  安装，对应go install：
:GoInstall  测试，对应go test：
:GoTest  运行一个单独测试：
:GoTestFunc  覆盖率：
:GoCoverage  运行当前程序，对应go run:
:GoRun  goto符号定义：
:GoDef  文档查询：
:GoDoc :GoDocBrowser  添加／删除包引用：
:GoImport :GoDrop  设置GOPATH：
:GoPath  在结构体增加／删除tag：
:GoAddTags :GoRemoveTags  静态语法检查：
:GoMetaLinter // 调用gometalinter :GoLint // 调用golint  高级代码分析：
:GoImplements :GoCallees :GoReferrers  重命名：
:GoRename  在vim中查询vim-go的帮助文档： :help vim-go  安装完成后打开vim，运行&amp;rdquo;:GoInstallBinaries&amp;rdquo;安装依赖的工具。
再安装其它依赖工具：
// gocode is used by many editors to provide intellisense go get github.</description>
    </item>
    
    <item>
      <title>Temp Sensor Comparasion</title>
      <link>https://www.singleye.net/2017/11/temp-sensor-comparasion/</link>
      <pubDate>Fri, 10 Nov 2017 11:56:13 +0800</pubDate>
      
      <guid>https://www.singleye.net/2017/11/temp-sensor-comparasion/</guid>
      <description>DS18B20 PT100
    DS18B20 PT100     器件稳定性     温度测量范围 -55～125℃ -200～850℃   测温时延     精度偏差 +-0.5℃ B级别可达0.5%，精度较高，但需要校准   年漂移量     工作电压 3-5.5V    体积 稍大，探头直径6mm 较小，探头直径5mm   引线长度 最长30米    信号接口数量 3 2   成本     寿命     开发难度 容易，直接数字信号输出 相对复杂，需要校准   特点 具有体积小、硬件开销低、抗干扰能力强、精度高的特点     </description>
    </item>
    
    <item>
      <title>使用vim进行16进制编辑</title>
      <link>https://www.singleye.net/2017/11/%E4%BD%BF%E7%94%A8vim%E8%BF%9B%E8%A1%8C16%E8%BF%9B%E5%88%B6%E7%BC%96%E8%BE%91/</link>
      <pubDate>Thu, 09 Nov 2017 10:27:00 +0000</pubDate>
      
      <guid>https://www.singleye.net/2017/11/%E4%BD%BF%E7%94%A8vim%E8%BF%9B%E8%A1%8C16%E8%BF%9B%E5%88%B6%E7%BC%96%E8%BE%91/</guid>
      <description>记录一下使用vim编辑二进制文件的方法，这个方法使用了vim执行 &amp;lsquo;%!&amp;rsquo; 来打开外部程序的小技巧。
使用vim打开任意文件，并运行下面命令便进入16禁止编辑模式：
:%!xxd  退出时一定要记得使用下面命令，将编辑的hexdump内容还原成二进制：
:%!xxd -r  使用这个技巧需要注意的是打开二进制文件编辑模式必须使用&amp;rsquo;-b&amp;rsquo;参数，否则vim会在编辑内容末尾增加0x0a字符，保存的时候也就会增加一个字节的信息。
使用&amp;rsquo;-b&amp;rsquo;参数：
00000000: 0011 2233 ..&amp;quot;3  不使用&amp;rsquo;-b&amp;rsquo;参数：
00000000: 0011 2233 0a ..&amp;quot;3.  </description>
    </item>
    
    <item>
      <title>Go语言中new与make的比较</title>
      <link>https://www.singleye.net/2017/11/go%E8%AF%AD%E8%A8%80%E4%B8%ADnew%E4%B8%8Emake%E7%9A%84%E6%AF%94%E8%BE%83/</link>
      <pubDate>Wed, 08 Nov 2017 10:58:00 +0000</pubDate>
      
      <guid>https://www.singleye.net/2017/11/go%E8%AF%AD%E8%A8%80%E4%B8%ADnew%E4%B8%8Emake%E7%9A%84%E6%AF%94%E8%BE%83/</guid>
      <description>go语言new()与make()的区别对于初入golang的开发者来说是个容易混淆的点，这里尝试对这两个的区别做一些总结。
官方文档 首先查找官方文档中的描述，首先是关于&amp;rsquo;new()&amp;lsquo;的：
1 2 3 4  // The new built-in function allocates memory. The first argument is a type, // not a value, and the value returned is a pointer to a newly // allocated zero value of that type. func new(Type) *Type   关于&amp;rsquo;make()&amp;rsquo;:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  // The make built-in function allocates and initializes an object of type // slice, map, or chan (only).</description>
    </item>
    
    <item>
      <title>GO语言中array与slice的比较</title>
      <link>https://www.singleye.net/2017/11/go%E8%AF%AD%E8%A8%80%E4%B8%ADarray%E4%B8%8Eslice%E7%9A%84%E6%AF%94%E8%BE%83/</link>
      <pubDate>Tue, 07 Nov 2017 14:25:00 +0000</pubDate>
      
      <guid>https://www.singleye.net/2017/11/go%E8%AF%AD%E8%A8%80%E4%B8%ADarray%E4%B8%8Eslice%E7%9A%84%E6%AF%94%E8%BE%83/</guid>
      <description>go语言中array与slice的区别总结
    数组array 切片slice 区别     声明定义 var arrayName [arrayLength] dataType var sliceName [] dataType 声明数组需要长度信息，定义slice时不需要   初始化 var arrayName = [arrayLength] dataType {Val1, &amp;hellip; Valn} var arrayName = [&amp;hellip;] dataType {Val1, &amp;hellip; Valn} var sliceName = [] dataType {Val1, &amp;hellip; Valn}var slice [] type = make([] type, length)通过数组初始化：slice := array[:]slice := array[startIndex:endIndex] 初始化数组时需要长度信息，初始化slice时不需要   取值 通过索引index取相应的元素值:arrayName[index] 通过index取元素值：slice[index] 返回一个新切片值: slice[startIndex:endIndex] slice取值除了可以获取一个元素的值外，还可以获取一个新的切片   赋值 元素赋值：array[index] = value  数组赋值： var new_array = array  new_array := array 元素赋值： slice[index] = value 将单个单个值append()到slice中，返回的新slice长度会增加:slice = append(slice, v1, v2&amp;hellip;) 将一个slice copy()到另一个slice中，目标slice长度不变，最多copy截止到目标元素最后一个元素： copy(slice1, slice2)  copy(slice1[si:], slice2) 数组支持简单的单元素或者整体赋值，slice则支持更加精细度的赋值   扩展 不支持 append()，新的slice length和capacity均发生变化： var slice = []int {1, 2, 3, 4, 5}slice = append(slice, 1, 2)fmt.</description>
    </item>
    
    <item>
      <title>Docker</title>
      <link>https://www.singleye.net/2017/10/docker/</link>
      <pubDate>Tue, 31 Oct 2017 23:59:00 +0000</pubDate>
      
      <guid>https://www.singleye.net/2017/10/docker/</guid>
      <description>1. 配置docker repository 2. Docker image image（镜像）保存docker中的可运行系统的数据，当运行时docker把image加载到container（容器）中运行。
2.1 获取docker image  命令： docker pull  Docker Registry: 地址的格式一般是 &amp;lt;域名/IP&amp;gt; :端口号 ，默认是docker hub。 仓库名：格式&amp;lt;用户名&amp;gt;/&amp;lt;软件名&amp;gt;，默认是Docker hub的&amp;rdquo;Library&amp;rdquo;。    docker pull [选项] [Docker Registry地址]:  2.2 查询image  命令：docker images   $ docker images REPOSITORY TAG IMAGE ID CREATED SIZE ubuntu 14.04 dea1945146b9 6 weeks ago 188MB  2.3 删除镜像 命令： docker rmi
 # 先查询镜像列表 $ docker images REPOSITORY TAG IMAGE ID CREATED SIZE ubuntu-mydev latest 0cbd01981d7e 7 weeks ago 761MB hyperledger/composer-playground 0.</description>
    </item>
    
    <item>
      <title>Macbook Air换电池记</title>
      <link>https://www.singleye.net/2017/10/macbook-air%E6%8D%A2%E7%94%B5%E6%B1%A0%E8%AE%B0/</link>
      <pubDate>Fri, 06 Oct 2017 01:58:00 +0000</pubDate>
      
      <guid>https://www.singleye.net/2017/10/macbook-air%E6%8D%A2%E7%94%B5%E6%B1%A0%E8%AE%B0/</guid>
      <description>家里的Macbook Air年事已高电池也充不了电了，而且最近电池鼓包已经影响到了触摸板的使用，趁着假期买了块国产电池换上去。
秀一下新电池和拆机工具： Air后盖的螺丝是特殊的5角形状必需用电池包里的黄色螺丝刀把10颗螺丝先拧下来： 拆下后盖发现鼓包的电池块了，没想到都鼓到这种程度了 -___-! 拆电池也很简单，用附带的黑色螺丝刀把图里面标红的螺丝拆下来就搞定了，别忘记把电池跟主板连接的插销取下来： 换电池之前给Air做了次内部SPA看起来清爽多了！ 安装电池也非常的方便，按照拆下来的顺序装回去就完成了！ </description>
    </item>
    
    <item>
      <title>softmax输出层公式推导及代码实验</title>
      <link>https://www.singleye.net/2017/10/softmax%E8%BE%93%E5%87%BA%E5%B1%82%E5%85%AC%E5%BC%8F%E6%8E%A8%E5%AF%BC%E5%8F%8A%E4%BB%A3%E7%A0%81%E5%AE%9E%E9%AA%8C/</link>
      <pubDate>Mon, 02 Oct 2017 02:11:00 +0000</pubDate>
      
      <guid>https://www.singleye.net/2017/10/softmax%E8%BE%93%E5%87%BA%E5%B1%82%E5%85%AC%E5%BC%8F%E6%8E%A8%E5%AF%BC%E5%8F%8A%E4%BB%A3%E7%A0%81%E5%AE%9E%E9%AA%8C/</guid>
      <description>sigmoid激活函数在神经网络中有着强大的通用性，但也存在这一些问题，比如：
 在w/b参数还没有训练成熟时，训练预测偏差较大，此时的训练速度会较慢。这个问题的解决方法有两种：  使用交叉熵代价函数: $ C = -{1\over n} \sum_{i=1}^n [y_i \ln a_i + (1-y_i) \ln (1-a_i)] $ 使用softmax和log-likelyhood代价函数作为输出层  sigmoid的输出结果是伯努利分布 $ P(y_1|X), P(y_2|X), &amp;hellip; P(y_n|X) $，说明每一个输出项之间是相互独立的，这在预测一种输出结果的情形时不太符合人们的直观感受。这个问题也可以用softmax输出层解决，因为softmax的输出是多项分布：$ P(y_1, y_2, &amp;hellip; y_n | X) $，其中y1, &amp;hellip; yn之间相互关联，且总和为1。  这样看起来softmax是个很有效的方法，下面就对这个方法进行一些研究。
softmax定义：  $$ softmax(z_j) = {e^{z_j} \over {\sum_{i=1}^m e^{z_i} }} , j=1, ... m $$  将softmax层应用在网络输出层时，每一个神经元的softmax激活输出可以理解为该神经元对应结果的预测概率，这里有几个基本事实：
 每个神经元的输出为正数，并且输出数值介于0-1之间。 所有神经元的输出总和为1。 某一项输入（Z值）增大时，其对应的输出概率增大；同时其他输出概率同时减小（总和总是1）。该结论可以从$ \frac {\partial a_i} {\partial {z_i}} $（总为正数）以及$ \frac {\partial a_i} {\partial {z_j}}$（总为负数）推算出来，这两个数字也说明了softmax的输入／输出单调性。 softmax的每个激活输出值之间相互关联，表现出了输出非局部性特征。直观的理解就是因为所有激活输出的总和总是为1，那么其中一个激活输出的值发生变动的时候其他的激活输出也必将变化。这一点也是跟sigmoid激活函数的很不同的一点，也说明了$ \frac {\partial a_i} {\partial {z_j}}$值存在的意义。  下图展示了softmax层工作的基本原理。</description>
    </item>
    
    <item>
      <title>神经网络之反向传播算法</title>
      <link>https://www.singleye.net/2017/09/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B9%8B%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E7%AE%97%E6%B3%95/</link>
      <pubDate>Mon, 25 Sep 2017 15:44:00 +0000</pubDate>
      
      <guid>https://www.singleye.net/2017/09/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B9%8B%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E7%AE%97%E6%B3%95/</guid>
      <description>之前使用神经网络算法的时候并没有认真总结关键的算法，虽然可以用但总觉得不爽，于是这两天对神经网络算法中的反向传播（Back Propagation）进行了推导。即理解了算法的数学本质，也对神经网络算法的工程特性有了深刻体会，工程算法真的是以解决问题为驱动的，追求的是解决问题的实用性。
神经网络 网络拓扑 神经元 神经元是神经网络的基本构成，上图的每一个圆圈代表了一个神经元。每一个神经元有一个输入和一个输出，神经元的作用是对输入值进行计算。下图是一个神经元的简单示意图：
 该神经元的输出：$ a=f(z)=sigmoid(z) $  神经元输入 在一个复杂点的神经网络中，一个神经元接收来自多个前级神经元的激活输出，并进行加权相加后产生该神经元的输入值，这个过程示意图如下：
定义第 $ l^{th} $ 层第 $ j^{th} $ 个神经元的输入：
神经元加权 神经元的加权结构可以看下面的示意图：
注，第一层神经元的输入就是采样数据，不需要计算z值，这层采样数据直接通过权重计算输入到第二层的神经元。
反向传播算法 代价函数 定义代价函数：$ cost = {1 \over 2} \sum (y^{(i)} - a^{(i)})^2 $
神经元错误量 $ \delta_j^{(l)} $ 每个神经元的输入记为&amp;rsquo;z&amp;rsquo;，经过激活函数&amp;rsquo;f(z)&amp;lsquo;生成激活值&amp;rsquo;a&amp;rsquo;，通常情况下激活函数使用sigmoid()。那么假设对于每个神经元的输入&amp;rsquo;z&amp;rsquo;做一点微小的改变记为 $ \Delta z $，由这个改变引起的代价变化记为这个神经元的错误量 $ \delta_j^{(l)} $，从这个定义可以看出来这是一个代价函数相对于神经元的输入&amp;rsquo;z&amp;rsquo;的偏导数。
定义 $ \delta_j^{(l)} $ 为 $ l^{th} $ 层中的第 $ j^{th} $ 个神经元的错误量，记作：$ \delta_j^{(l)} =\frac{\partial C}{\partial z_j^{(l)}} $
经过数学推导可以得出结论：</description>
    </item>
    
    <item>
      <title>在 Nvidia Jetson TX2 上编译安装tensorflow</title>
      <link>https://www.singleye.net/2017/09/%E5%9C%A8-nvidia-jetson-tx2-%E4%B8%8A%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85tensorflow/</link>
      <pubDate>Thu, 14 Sep 2017 00:22:00 +0000</pubDate>
      
      <guid>https://www.singleye.net/2017/09/%E5%9C%A8-nvidia-jetson-tx2-%E4%B8%8A%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85tensorflow/</guid>
      <description>系统环境  Jetpack：v3.0 CUDA：8.0 cuDNN：5.1.10  编译安装bazel bazel是google开发的一套开发管理工具，功能类似makefile和maven，特点是速度快，编译tensorflow时需要用到这个工具。
在TX2上安装bazel需要对bazel源代码做一点修改以支持该平台。下载代码后修改文件 &amp;ldquo;bazel/src/main/java/com/google/devtools/build/lib/util/CPU.java&amp;rdquo;，修改如下：
public enum CPU { X86_32(&amp;quot;x86_32&amp;quot;, ImmutableSet.of(&amp;quot;i386&amp;quot;, &amp;quot;i486&amp;quot;, &amp;quot;i586&amp;quot;, &amp;quot;i686&amp;quot;, &amp;quot;i786&amp;quot;, &amp;quot;x86&amp;quot;)), X86_64(&amp;quot;x86_64&amp;quot;, ImmutableSet.of(&amp;quot;amd64&amp;quot;, &amp;quot;x86_64&amp;quot;, &amp;quot;x64&amp;quot;)), PPC(&amp;quot;ppc&amp;quot;, ImmutableSet.of(&amp;quot;ppc&amp;quot;, &amp;quot;ppc64&amp;quot;, &amp;quot;ppc64le&amp;quot;)), - ARM(&amp;quot;arm&amp;quot;, ImmutableSet.of(&amp;quot;arm&amp;quot;, &amp;quot;armv7l&amp;quot;)), + ARM(&amp;quot;arm&amp;quot;, ImmutableSet.of(&amp;quot;arm&amp;quot;, &amp;quot;armv7l&amp;quot;, &amp;quot;aarch64&amp;quot;)), S390X(&amp;quot;s390x&amp;quot;, ImmutableSet.of(&amp;quot;s390x&amp;quot;, &amp;quot;s390&amp;quot;)), UNKNOWN(&amp;quot;unknown&amp;quot;, ImmutableSet.&amp;lt;String&amp;gt;of());  修改好之后在代码目录运行 &amp;ldquo;compile.sh&amp;rdquo; 进行编译，编译好后将程序拷贝到执行环境：
$ sudo cp output/bazel /usr/local/bin  安装tensorflow 下载tensorflow源码 写这篇文章的时候tensorflow已经发展到了v1.3，下载release版本代码：
$ wget https://github.com/tensorflow/tensorflow/archive/v1.3.0.tar.gz  编译tensorflow  配置configure  首先configure编译环境：
nvidia@tegra-ubuntu:~/tensorflow/tensorflow-1.3.0$ ./configure You have bazel 0.</description>
    </item>
    
    <item>
      <title>数学期望、方差、标准差、协方差</title>
      <link>https://www.singleye.net/2017/09/%E6%95%B0%E5%AD%A6%E6%9C%9F%E6%9C%9B%E6%96%B9%E5%B7%AE%E6%A0%87%E5%87%86%E5%B7%AE%E5%8D%8F%E6%96%B9%E5%B7%AE/</link>
      <pubDate>Wed, 06 Sep 2017 18:51:00 +0000</pubDate>
      
      <guid>https://www.singleye.net/2017/09/%E6%95%B0%E5%AD%A6%E6%9C%9F%E6%9C%9B%E6%96%B9%E5%B7%AE%E6%A0%87%E5%87%86%E5%B7%AE%E5%8D%8F%E6%96%B9%E5%B7%AE/</guid>
      <description>最近在学习机器学习的过程中发现了许多上学时在概率论和统计学课上学过的知识点，可是年代久远已经都忘记了，重新学起来还是费了不少力气，不过因为带着目的学习所以也有了一些新的认识。
数学期望（mean） 概率论中描述一个随机事件中的随机变量的平均值的大小可以使用“数学期望”（mean）这个概念。
数学期望的定义是实验中每次可能的结果的概率乘以其结果的总和。
离散型随机量的数学期望  定义：离散型随机变量的所有可能取值 $ x_i $ 与其对应的概率 $ P( x_i ) $ 乘积的和为该离散型随机量的数学期望，记为 $ E(X) $。
 公式：$$ E(X) = \sum_{i=1}^n x_i P_i$$
  连续型随机量的数学期望  定义：假设连续型随机变量 $ X $ 的概率密度函数为 $ f(x) $ ，如果积分 $ \int_{-\infty}^{+\infty} xf(x) \,{\rm d}x $ 绝对收敛，则称这个积分的值为连续型随机量的数学期望，记为 $ E(X) $。
 公式：$$ E(X) = \int_{-\infty}^{+\infty} xf(x) \,{\rm d}x $$
  数学期望的性质  设C为常数： $ E(C) = C $ 设C为常数： $ E(CX) = CE(X) $ 加法：$ E(X+Y) = E(X) + E(Y) $ 当X和Y相互独立时，$ E(XY) = E(X)E(Y) $ （主意，X和Y的相互独立性可以通过下面的“协方差”描述）  数学期望的意义 根据根据“大数定律”的描述，这个数字的意义是指随着重复次数接近无穷大时，数值的算术平均值几乎肯定收敛于数学期望值，也就是说数学期望值可以用于预测一个随机事件的平均预期情况。</description>
    </item>
    
    <item>
      <title>The Current State of Machine Intelligence (from Shivon Zilis)</title>
      <link>https://www.singleye.net/2017/09/the-current-state-of-machine-intelligence-from-shivon-zilis/</link>
      <pubDate>Fri, 01 Sep 2017 14:29:00 +0000</pubDate>
      
      <guid>https://www.singleye.net/2017/09/the-current-state-of-machine-intelligence-from-shivon-zilis/</guid>
      <description>看到几张描绘近几年来机器学习领域的行业版图：
&amp;ldquo;The Current State of Machine Intelligence 3.0&amp;rdquo; published in 2016 by Shivon Zilis
&amp;ldquo;The current state of machine intelligence 2.0&amp;rdquo; published in 2015 by Shivon Zilis
&amp;ldquo;The Current State of Machine Intelligence&amp;rdquo; published in 2014 by Shivon Zilis</description>
    </item>
    
    <item>
      <title>用scrapy爬取京东商品信息</title>
      <link>https://www.singleye.net/2017/08/%E7%94%A8scrapy%E7%88%AC%E5%8F%96%E4%BA%AC%E4%B8%9C%E5%95%86%E5%93%81%E4%BF%A1%E6%81%AF/</link>
      <pubDate>Thu, 31 Aug 2017 09:46:00 +0000</pubDate>
      
      <guid>https://www.singleye.net/2017/08/%E7%94%A8scrapy%E7%88%AC%E5%8F%96%E4%BA%AC%E4%B8%9C%E5%95%86%E5%93%81%E4%BF%A1%E6%81%AF/</guid>
      <description>scrapy是一个非常著名的爬虫框架，使用这个框架可以非常容易的生成一个网站爬虫程序框架，之后就可以在框架之上方便的进行爬虫的编写。
进来想要了解一些产品的市场信息，就用scrapy写了个简单的爬虫，写个笔记记录一下。
安装 使用python环境的话最好通过pip进行安装，这样操作简单方便，直接使用下面的命令即可：
$ pip install scrapy  scrapy框架提供了&amp;rsquo;scrapy&amp;rsquo;命令进行项目的创建及运行管理，所以首先看一下
$ scrapy --help Scrapy 1.4.0 - no active project Usage: scrapy &amp;lt;command&amp;gt; [options] [args] Available commands: bench Run quick benchmark test fetch Fetch a URL using the Scrapy downloader genspider Generate new spider using pre-defined templates runspider Run a self-contained spider (without creating a project) settings Get settings values shell Interactive scraping console startproject Create new project version Print Scrapy version view Open URL in browser, as seen by Scrapy [ more ] More commands available when run from project directory Use &amp;quot;scrapy &amp;lt;command&amp;gt; -h&amp;quot; to see more info about a command  创建项目 首先使用&amp;rsquo;scrapy startproject&amp;rsquo;创建项目</description>
    </item>
    
    <item>
      <title>神经网络实践：自动驾驶</title>
      <link>https://www.singleye.net/2017/08/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%AE%9E%E8%B7%B5%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6/</link>
      <pubDate>Thu, 17 Aug 2017 20:01:00 +0000</pubDate>
      
      <guid>https://www.singleye.net/2017/08/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%AE%9E%E8%B7%B5%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6/</guid>
      <description>最近学习了下神经网络，于是写了一个开车的小游戏，然后训练了一个6层神经网络自己驾驶练练手。
代码实现主要用了pygame和numpy，网络有7个输入分别对应小车前面的7个距离探头数据，2个输出进行转向输出。
 您还没有安装flash播放器,请点击 这里 安装</description>
    </item>
    
    <item>
      <title>图像卷积实践</title>
      <link>https://www.singleye.net/2017/07/%E5%9B%BE%E5%83%8F%E5%8D%B7%E7%A7%AF%E5%AE%9E%E8%B7%B5/</link>
      <pubDate>Sun, 30 Jul 2017 18:30:50 +0800</pubDate>
      
      <guid>https://www.singleye.net/2017/07/%E5%9B%BE%E5%83%8F%E5%8D%B7%E7%A7%AF%E5%AE%9E%E8%B7%B5/</guid>
      <description>最近对图像识别技术很感兴趣，了解到在这个领域中CNN的应用可以比较有效的解决问题，这里对卷积（convolution）相关的知识进行一下记录说明。
图像卷积是什么？ 将一张图片看作一张像素的矩阵的话，卷积就是把另一个矩阵（卷积核）在这张图片上移动，在移动的过程中取图片上对应大小的矩阵与卷积核进行运算，每次矩阵运算得出的结果保存成一个新的像素，这个过程就是图像的卷积运算。
卷积的过程可以用下面的示意图展示：
为什么做卷积？ 一张原始图像包含了大量的噪音信息，这些噪音信息会干扰后续的运算过程。如果将一张图像看作一个输入信号的话，如果找到一种过滤器将噪音信息过滤掉就可以提高后续运算的准确度。卷积就是这么一个过滤器，这个过滤器的正式称呼是卷积核。
那么这个过滤器可以做些什么呢？其实常见的图像处理软件早已经在使用卷积进行图片处理了，比如图像锐化、模糊、浮雕效果等等&amp;hellip;
下面收集了一些常用的过滤器，对这张图片处理后可以看一下效果。
 图像边界检测   $$ \left[ \begin{matrix} -1 &amp; -1 &amp; -1 \\ -1 &amp; 8 &amp; -1 \\ -1 &amp; -1 &amp; -1 \end{matrix} \right] $$   图像模糊   $$ \left[ \begin{matrix} 0 &amp; 1 &amp; 0 \\ 1 &amp; 1 &amp; 1 \\ 0 &amp; 1 &amp; 0 \end{matrix} \right] $$   图像锐化   $$ \left[ \begin{matrix} -1 &amp; -1 &amp; -1 \\ -1 &amp; 9 &amp; -1 \\ -1 &amp; -1 &amp; -1 \end{matrix} \right] $$   浮雕   $$ \left[ \begin{matrix} -1 &amp; -1 &amp; 0 \\ -1 &amp; 0 &amp; 1 \\ 0 &amp; 1 &amp; 1 \end{matrix} \right] $$  用numpy进行卷积计算 以上的图片使用下面的算法生成，主要使用了numpy的array进行的计算。通过该算法生成的图片效果还不够理想：</description>
    </item>
    
    <item>
      <title>python中__main__的作用域及变量使用</title>
      <link>https://www.singleye.net/2017/06/python%E4%B8%AD__main__%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%8F%8A%E5%8F%98%E9%87%8F%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Sat, 10 Jun 2017 23:00:31 +0800</pubDate>
      
      <guid>https://www.singleye.net/2017/06/python%E4%B8%AD__main__%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%8F%8A%E5%8F%98%E9%87%8F%E4%BD%BF%E7%94%A8/</guid>
      <description>今天使用python写一段小程序时发现了一个容易忽略掉的变量作用域的细节。先看一下问题。
$ cat main_variable.py x = 1 if __name__ == &amp;quot;__main__&amp;quot;: global x x = 2 $ python main_area.py main_area.py:4: SyntaxWarning: name &#39;x&#39; is assigned to before global declaration global x  程序的本来目的是在对全局变量前使用global进行声明，但却引发了SyntaxWarning异常。问题原因其实也很简单，因为虽然使用&amp;rsquo;if name == &amp;ldquo;main&amp;rdquo;&amp;lsquo;进行判断后再执行，但代码还是处于整个文件的作用域中，因此并不需要使用global进行声明。
因此程序可以有下面两种改法：
 方法1:  $ cat main_variable.py x = 1 if __name__ == &amp;quot;__main__&amp;quot;: x = 2 $ python main_area.py   方法2:  $ cat main_variable.py x = 1 def main(): global x x = 2 if __name__ == &amp;quot;__main__&amp;quot;: main() $ python main_area.</description>
    </item>
    
    <item>
      <title>nmap NSE脚本中host/port的内容</title>
      <link>https://www.singleye.net/2017/06/nmap-nse%E8%84%9A%E6%9C%AC%E4%B8%ADhost/port%E7%9A%84%E5%86%85%E5%AE%B9/</link>
      <pubDate>Sun, 04 Jun 2017 21:12:03 +0800</pubDate>
      
      <guid>https://www.singleye.net/2017/06/nmap-nse%E8%84%9A%E6%9C%AC%E4%B8%ADhost/port%E7%9A%84%E5%86%85%E5%AE%B9/</guid>
      <description>周末写了一个简单的nmap的NSE脚本，其中使用了nmap API中的host,port两个变量，数据结构记录。
Host
   Key Value     registry table: 0x7feae1dc5080   name    reason_ttl 0   bin_ip    ip 192.168.1.10   reason user-set   interface_mtu 0   times table: 0x7feae1d9dbf0       Key Value     number 443   reason syn-ack   version table: 0x7feae1dfb720   state open   reason_ttl 0   service https   protocol tcp    https://nmap.</description>
    </item>
    
    <item>
      <title>esp8266_sprint_float</title>
      <link>https://www.singleye.net/2017/05/esp8266_sprint_float/</link>
      <pubDate>Fri, 12 May 2017 10:34:42 +0800</pubDate>
      
      <guid>https://www.singleye.net/2017/05/esp8266_sprint_float/</guid>
      <description>用C语言进行字符串格式化操作的时候经常会使用sprintf/snprintf这两个函数，但这两天在使用Arduino IDE进行8266开发的时候却碰到了一个浮点数字符串打印小问题。
问题代码
 char buffer[128]; float num = 1.0; ... memset(buffer, 0, sizeof(buffer)); snprintf(buffer, sizeof(buffer), “%f”, num); Serial.println(buffer);  实际运行并没有按照以往认为的方式将浮点数输出出来
 snprintf(buffer, sizeof(buffer), &amp;quot;%d.&amp;quot;);  </description>
    </item>
    
    <item>
      <title>esp8266启动模式 - 如何理解&#39;rst cause:2, boot mode:(3,6)&#39;</title>
      <link>https://www.singleye.net/2017/05/esp8266%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F---%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3rst-cause2-boot-mode36/</link>
      <pubDate>Mon, 08 May 2017 00:23:11 +0800</pubDate>
      
      <guid>https://www.singleye.net/2017/05/esp8266%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F---%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3rst-cause2-boot-mode36/</guid>
      <description>8266模块启动或者出现问题后重启时会输出类似&amp;lsquo;rst cause:2, boot mode:(3,6)&amp;rsquo;的消息，这个模块的启动消息可以看出启动的原因和模式。
rst cause:2, boot mode:(3,6)  &amp;lsquo;rst cause&amp;rsquo; &amp;lsquo;rst cause&amp;rsquo;含义如下：
   编号 描述     0 unknown   1 normal boot   2 reset pin   3 software reset   4 watchdog reset    &amp;lsquo;boot mode&amp;rsquo; 消息中内容的&amp;lsquo;boot mode:(x,y)&amp;rsquo;中的&amp;lsquo;x&amp;rsquo;表示GPIO &amp;lsquo;15/0/2&amp;rsquo; 3个端口的二进制数（有电压为1，没电压为0）。
启动模式 = ((GPIO15 &amp;lt;&amp;lt; 2) | (GPIO0 &amp;lt;&amp;lt; 1) | GPIO2);  由于模块启动的时候会检查0/2/15端口的状态，理解这个数字的意义需要先了解模块的启动模式。
   启动模式 GPIO15 (MTDO) GPIO0 GPIO2 启动模式     0 0V 0V 0V 无效   1 0V 0V 3.</description>
    </item>
    
    <item>
      <title>在ESP 8266 nodeMCU上运行MQTT</title>
      <link>https://www.singleye.net/2017/05/%E5%9C%A8esp-8266-nodemcu%E4%B8%8A%E8%BF%90%E8%A1%8Cmqtt/</link>
      <pubDate>Sun, 07 May 2017 16:20:58 +0800</pubDate>
      
      <guid>https://www.singleye.net/2017/05/%E5%9C%A8esp-8266-nodemcu%E4%B8%8A%E8%BF%90%E8%A1%8Cmqtt/</guid>
      <description>自动接触nodeMCU后发现8266是一个非常好的物联网开发Wi-Fi模块，因此就想把MQTT通讯协议在上面运行起来做些简单的事情。
开发目标  将nodeMCU作为一个MQTT的客户端运行。 使用PubSubClient这个MQTT协议实现。 程序每次启动后先把将芯片设置到STA模式下，并连接指定的WI-FI路由器。 连接建立好之后连接指定的MQTT服务器，并注册从服务器接收数据的topic，并定期将数据（uptime）发送到服务器端指定的topic上。  上传topic：&amp;rdquo;MAC地址/uplink&amp;rdquo; 接收topic：&amp;rdquo;MAC地址/downlink&amp;rdquo;  当收到downlink消息后把数据进行解析并执行，目前只支持&amp;rsquo;blink&amp;rsquo;命令。该命令可以把芯片上的LED灯按照指定的次数点亮的简单操作。  程序开发 程序启动设置 程序启动的入口为&amp;rsquo;setup()&amp;lsquo;函数，这个函数做几件事情：
 设置LED控制PIN模式 将WI-FI芯片设置到STA运行模式，并连接Wi-Fi路由器 连接MQTT服务器，监听&amp;rsquo;downlink&amp;rsquo;消息  程序片段解析：
void setup() { Serial.begin(BAUD_RATE); pinMode(LED_PIN, OUTPUT); // 设置LED控制端口 WiFi.disconnect(); WiFi.mode(WIFI_STA); // 设置启动为STA模式 WiFi.setAutoConnect(true); WiFi.begin(wifi_ssid, wifi_pwd); // 连接Wi-Fi路由器 Serial.printf(&amp;quot;Connecting to AP(%s), password(%s)\n&amp;quot;, wifi_ssid, wifi_pwd); while (WL_CONNECTED != WiFi.status()) { Serial.print(&amp;quot;.&amp;quot;); blink(BLINK_SLOWLY); } Serial.printf(&amp;quot;\nWifi connection is setup!\n&amp;quot;); Serial.printf(&amp;quot;MAC: %s, IP: %s\n&amp;quot;, WiFi.macAddress().c_str(), WiFi.localIP().toString().c_str()); while (!setup_mqtt_connection()) { // 连接MQTT服务器 Serial.print(&amp;quot;.&amp;quot;); blink(BLINK_SLOWLY); } }  连接MQTT服务器 这个方法的工作就是建立连接并且注册接收的topic。</description>
    </item>
    
    <item>
      <title>如何在CentOS上部署shadowsocks服务</title>
      <link>https://www.singleye.net/2017/05/%E5%A6%82%E4%BD%95%E5%9C%A8centos%E4%B8%8A%E9%83%A8%E7%BD%B2shadowsocks%E6%9C%8D%E5%8A%A1/</link>
      <pubDate>Mon, 01 May 2017 23:39:03 +0800</pubDate>
      
      <guid>https://www.singleye.net/2017/05/%E5%A6%82%E4%BD%95%E5%9C%A8centos%E4%B8%8A%E9%83%A8%E7%BD%B2shadowsocks%E6%9C%8D%E5%8A%A1/</guid>
      <description>shadowsocks简单介绍 shadowsocks是目前较流行的一种科学上网服务。他的工作原理也比较简单，shadowsocks本质上是socks5代理技术，然而架构方式上将单服务节点拆分成两个子服务：SS Local和SS Server。
工作过程如下：
 当本地请求端需要访问时首先将请求发送至本地SS Local服务 SS Local将数据加密在网络上传输到SS Server，由于信息经过加密不会被GFW提取到特征数据，因此也就翻了墙 SS Server收到数据后解密并访问真正的远程服务资源 远程返回数据返回到SS Server SS Server将数据加密传输给SS Local SS Local收到返回数据解密后发给本地请求端  部署shadow socks服务 (SS Server) 安装服务 shadowsocks服务的部署也极为简单，已经有完善的脚本帮助安装，需要稍微注意下的就是安装过程需要root权限，安装方法如下：
# wget --no-check-certificate -O shadowsocks.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.sh # sh shadowsocks.sh  配置服务 shadowsocks的配置文件是&amp;rsquo;/etc/shadowsocks.json&amp;rsquo;，一个简单的配置文件的写法可以参考这个例子。
# cat /etc/shadowsocks.json { &amp;quot;server&amp;quot;:&amp;quot;0.0.0.0&amp;quot;, &amp;quot;port_password&amp;quot;:{ &amp;quot;8989&amp;quot;:&amp;quot;password1&amp;quot;, &amp;lt;--- 第一个服务端口及访问密码 &amp;quot;8990&amp;quot;:&amp;quot;password2&amp;quot; &amp;lt;--- 多个服务端口指定方法 }, &amp;quot;timeout&amp;quot;:300, &amp;quot;method&amp;quot;:&amp;quot;aes-256-cfb&amp;quot;, &amp;lt;--- 注意这个加密方式，配置SS Local需要使用 &amp;quot;fast_open&amp;quot;:false, &amp;quot;workers&amp;quot;:2 }  多数情况下一个端口就可以满足使用了，这个例子中提供了多个访问端口的配置方法，具体用法可以根据自己的实际情况配置。
启动服务 服务安装过程同时会安装一个启动脚本&amp;rsquo;/etc/init.d/shadowsocks&amp;rsquo;，启动方法也很简单。
# service shadowsocks start  为了确保每次系统启动后服务会自动运行最好将服务使用chkconfig进行启用，这样就不必担心系统被运营商或者管理员维护重启后无法使用了。</description>
    </item>
    
    <item>
      <title>使用Arduino IDE进行nodeMCU开发</title>
      <link>https://www.singleye.net/2017/04/%E4%BD%BF%E7%94%A8arduino-ide%E8%BF%9B%E8%A1%8Cnodemcu%E5%BC%80%E5%8F%91/</link>
      <pubDate>Wed, 12 Apr 2017 19:10:33 +0800</pubDate>
      
      <guid>https://www.singleye.net/2017/04/%E4%BD%BF%E7%94%A8arduino-ide%E8%BF%9B%E8%A1%8Cnodemcu%E5%BC%80%E5%8F%91/</guid>
      <description>安装Arduino IDE 这两天发现使用Arduino IDE开发nodeMCU(ESP 8266)非常方便，写出来分享一下。
1.下载arduino IDE
Arduino IDE可以在Arduino官网下载到。
2.配置开发板管理器网址
打开preference，用下面的URL设置“附加开发模版管理器网址”：
http://arduino.esp8266.com/stable/package_esp8266com_index.json  3.下载更新8266开发模版
打开“工具”-&amp;gt;“开发板”-&amp;gt;“开发板管理器”，选择“esp8266”并安装。
安装完后在“工具”-&amp;gt;“开发板”中选择对应的开发板型号。
安装USB to UART驱动 nodeMCU自带Silicon Labs的USB芯片，可以直接使用microUSB进行连接，这对于不太熟悉硬件的爱好者是非常友好的。
连接前需要在这里下载驱动：nodeMCU USBtoUART驱动
设置UART端口 现在拿出一根microUSB线将nodeMCU连接到电脑上吧。
此时在Arduino IDE中还需要进行最后一个简单设置：“端口”。设置好这个端口后就可以跟板子进行串口通讯了。
设置过程通过“工具”-&amp;gt;“端口”进行选择。通常情况下应该选择类似&amp;rdquo;/dev/cu.SLAB_USBtoUART&amp;rdquo;字样的那个端口。
开发烧录程序 首先用Arduino IDE自带的例子程序进行说明开发过程。选择&amp;rdquo;文件&amp;rdquo;-&amp;gt;&amp;ldquo;示例&amp;rdquo;-&amp;gt;&amp;ldquo;01.Basics&amp;rdquo;-&amp;gt;&amp;ldquo;Blink&amp;rdquo;，将会打开&amp;rdquo;Blink&amp;rdquo;例子程序。
由于nodeMCU的LED灯连在16号管脚上，因此需要简单修改一下这个例子。
#define ESP8266_LED_BUILTIN 16 // the setup function runs once when you press reset or power the board void setup() { // initialize digital pin LED_BUILTIN as an output. pinMode(ESP8266_LED_BUILTIN, OUTPUT); } // the loop function runs over and over again forever void loop() { digitalWrite(ESP8266_LED_BUILTIN, HIGH); // turn the LED on (HIGH is the voltage level) delay(500); // wait for 0.</description>
    </item>
    
    <item>
      <title>在Mac OS上设置ESP 8266开发环境</title>
      <link>https://www.singleye.net/2017/04/%E5%9C%A8mac-os%E4%B8%8A%E8%AE%BE%E7%BD%AEesp-8266%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</link>
      <pubDate>Sat, 08 Apr 2017 00:10:24 +0800</pubDate>
      
      <guid>https://www.singleye.net/2017/04/%E5%9C%A8mac-os%E4%B8%8A%E8%AE%BE%E7%BD%AEesp-8266%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</guid>
      <description>做物联网产品开发有段时间了，虽然开发了两款智能产品，但hands-on的开发一直都在服务器和应用层进行，硬件层的研发并没有真的深入下去。决定有时间也对这个层面学习学习，软硬都能搞才算得上是全栈吧 :-P
要完成一个物联网产品的开发需要解决联网的问题。目前解决联网的比较常用的方案有Wi-Fi和GSM两种（NB-IOT也在上升势头，相信一年后会有较多的应用出现）。这次先学习下乐鑫ESP 8266 WI-FI芯片的开发。
由于我用的是Mac OS，所以就介绍如何在Mac上进行8266的环境设置。
安装使用esp-open-sdk 1.安装依赖关系
brew install gnu-sed --with-default-names brew tap homebrew/dupes brew install gperf brew install grep brew install autoconf brew install binutils brew install gawk brew install wget brew install automake brew install libtool brew install help2man  参考
2.准备case-sensitive分区
由于Mac OS的分区默认是case-insensitive的，而编译需要在case-sensitive的分区上进行，所以需要创建一个独立分区解决这个问题(linux系统上没有这个问题)。
hdiutil create ~/Desktop/eos.dmg -volname &amp;quot;esp-open-sdk&amp;quot; -size 10g -fs &amp;quot;Case-sensitive HFS+&amp;quot; hdiutil mount ~/Desktop/eos.dmg cd /Volumes/esp-open-sdk  3.编译esp-open-sdk
下载代码库，使用&amp;rsquo;&amp;ndash;recursive&amp;rsquo;会同时下载crosstool-NG／esp-open-lwip／esptool／lx106-hal子模块
git clone --recursive https://github.</description>
    </item>
    
    <item>
      <title>numpy学习笔记[1]</title>
      <link>https://www.singleye.net/2017/03/numpy%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/</link>
      <pubDate>Thu, 16 Mar 2017 14:45:31 +0800</pubDate>
      
      <guid>https://www.singleye.net/2017/03/numpy%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/</guid>
      <description>numpy数据结构 基本数据    数据类型 描述     bool 用一个字节存储的布尔类型（True或False）   inti 由所在平台决定其大小的整数（一般为int32或int64）   int8 一个字节大小，-128 至 127   int16 整数，-32768 至 32767   int32 整数，-2 ** 31 至 2 ** 32 -1   int64 整数，-2 ** 63 至 2 ** 63 - 1   uint8 无符号整数，0 至 255   uint16 无符号整数，0 至 65535   uint32 无符号整数，0 至 2 ** 32 - 1   uint64 无符号整数，0 至 2 ** 64 - 1   float16 半精度浮点数：16位，正负号1位，指数5位，精度10位   float32 单精度浮点数：32位，正负号1位，指数8位，精度23位   float64或float 双精度浮点数：64位，正负号1位，指数11位，精度52位   complex64 复数，分别用两个32位浮点数表示实部和虚部   complex128或complex 复数，分别用两个64位浮点数表示实部和虚部    array ‘array’表示元素数据大小固定的同质（相同数据类型）多维度数据。</description>
    </item>
    
    <item>
      <title>postgres数据库使用指南</title>
      <link>https://www.singleye.net/2017/03/postgres%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</link>
      <pubDate>Thu, 16 Mar 2017 00:08:17 +0800</pubDate>
      
      <guid>https://www.singleye.net/2017/03/postgres%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</guid>
      <description>在此省略postgres数据库的安装过程。
1. 初始化数据库环境 安装完postgres后需要先初始化数据库的环境，可以使用命令行工具 initdb 完成。
initdb &amp;lt;DB env path&amp;gt;  2. 数据库管理 2.1 创建数据库 方法1：使用命令行 createdb ，并直接指定用户
createdb -O &amp;lt;DB user&amp;gt; &amp;lt;DB name&amp;gt;  方法2：使用 SQL 创建
postgres# CREATE DATABASE xxxx2;  创建时指定数据库的拥有人：
postgres# CREATE DATABASE exampledb OWNER dbuser;  2.2 删除数据库 dropdb &amp;lt;DB name&amp;gt;  3. 用户及权限管理 3.1 添加用户 初始化完数据库环境后需要创建用户，之后再进行数据库创建和使用。
有两种方法可以创建用户：
方法1:使用命令行 createuser
createuser --interactive  按照提示信息一步步进行用户信息的输入就可以了。
方法2:使用命令行工具
sudo -s -u postgres psql postgres# CREATE USER xxxx1 WITH PASSWORD &#39;xxxx&#39;;  3.</description>
    </item>
    
    <item>
      <title>tensorflow playground</title>
      <link>https://www.singleye.net/2017/02/tensorflow-playground/</link>
      <pubDate>Sat, 18 Feb 2017 17:39:21 +0800</pubDate>
      
      <guid>https://www.singleye.net/2017/02/tensorflow-playground/</guid>
      <description>Tensorflow playground，感受一下machine learning的奇特之处：http://playground.tensorflow.org</description>
    </item>
    
    <item>
      <title>玩转阿波罗11号飞船导航计算机模拟器</title>
      <link>https://www.singleye.net/2017/01/%E7%8E%A9%E8%BD%AC%E9%98%BF%E6%B3%A2%E7%BD%9711%E5%8F%B7%E9%A3%9E%E8%88%B9%E5%AF%BC%E8%88%AA%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%A8%A1%E6%8B%9F%E5%99%A8/</link>
      <pubDate>Fri, 27 Jan 2017 17:10:07 +0800</pubDate>
      
      <guid>https://www.singleye.net/2017/01/%E7%8E%A9%E8%BD%AC%E9%98%BF%E6%B3%A2%E7%BD%9711%E5%8F%B7%E9%A3%9E%E8%88%B9%E5%AF%BC%E8%88%AA%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%A8%A1%E6%8B%9F%E5%99%A8/</guid>
      <description>PS： 上个周末还在听王冠红人馆调侃河南空气质量监督特别小组的禁放政策出台3天后就撤销的节目，心想今年过年回家乡鞭炮还可以照常放，没想到还真的全面禁放了。没办法放鞭炮咱就“发射个火箭”玩玩吧:-)
前两天在Github上看到一个有趣的项目，是当年美国登月计划“阿波罗号”的导航计算机的源代码，并且Virtual AGC MIT museum还开发了运行用的模拟器，使用这个模拟器能够运行导航计算机中的“指令模块”和“登月模块”。
估计很多人看过下面的张照片。没错，那等身的汇编代码现在可以在这个项目里面看到了！ 那么这个程序究竟是干什么的呢？要知道飞往月球并返回地球依靠宇航员手动是不可能的事情，当然也没有什么GPS，飞船必须沿着预定轨道航行才可以，这个程序就是保证飞船正确航行的导航程序。MIT仪器实验室为阿波罗计划开发了这套导航系统，这套导航计算机也叫“AGC (Apollo Guidance Computer)”，飞船上有有两套这样的导航系统，分别运行了不同的程序，一个是CM (Command Module)用来把宇航员送往月球并且返回，另一个是LM (Lunar Module)用来把宇航员送到月球表面并且返回飞船。
先来看看这货到底长什么样子吧。PS: 体格上好像当年玩过的EMC 60块盘的DAE&amp;hellip;  2048字（不到4kB）的内存 36,864字（不到72kB）的只读存储 每秒钟最多可执行85,000条指令 尺寸: 24&amp;rdquo;×12.5&amp;rdquo;×6&amp;rdquo; (英寸). 重达70.1磅 使用28V 2.5A的直流电  显示器和键盘(DSKY)看起来就跟一个普通计算器差不多。 故事先讲到这儿，来看看怎样把这个模拟器跑起来吧。
1. 下载代码库 1$ git clone https://github.com/virtualagc/virtualagc.git 2. 编译代码 我使用的环境是CentOS 6.5，为了编译通过需要对Makefile做一些小的修改： 1$ cd virtualagc 2$ git diff Makefile yaAGCb1/Makefile 3diff --git a/Makefile b/Makefile 4index 773edf2..0e9ff8c 100644 5--- a/Makefile 6+++ b/Makefile 7@@ -321,7 +321,7 @@ LIBS+=-lwsock32 8 CURSES=../yaAGC/random.c 9 CURSES+=-lregex 10 else 11-CURSES=-lcurses 12+CURSES=-lncurses 13 endif 14 15 ifdef MACOSX 16diff --git a/yaAGCb1/Makefile b/yaAGCb1/Makefile 17index faf4c5e.</description>
    </item>
    
    <item>
      <title>阿里云ECS EIP服务进行IPv6改造的方法</title>
      <link>https://www.singleye.net/2017/01/%E9%98%BF%E9%87%8C%E4%BA%91ecs-eip%E6%9C%8D%E5%8A%A1%E8%BF%9B%E8%A1%8Cipv6%E6%94%B9%E9%80%A0%E7%9A%84%E6%96%B9%E6%B3%95/</link>
      <pubDate>Wed, 18 Jan 2017 18:56:51 +0800</pubDate>
      
      <guid>https://www.singleye.net/2017/01/%E9%98%BF%E9%87%8C%E4%BA%91ecs-eip%E6%9C%8D%E5%8A%A1%E8%BF%9B%E8%A1%8Cipv6%E6%94%B9%E9%80%A0%E7%9A%84%E6%96%B9%E6%B3%95/</guid>
      <description>最近团队开发的APP提交到苹果APP store时被拒了，原因是不支持IPv6的访问。原来苹果App store从2016年6月开始强制新上线APP支持IPv6网络，但由于IPv6基础设施在国内的推广非常缓慢，因此导致了该问题。
IPv6介绍 为了理解IPv6需要先了解其产生的原因，就是IPv4地址资源的问题。IPv4的网络使用32位的地址空间（XX.XX.XX.XX），因此最大支持的数量是4,294,967,296（2^32个），其中还有1800多万个私有地址和2.7亿个多播地址。互联网的发展显然超出了普通的32位地址空间的容量，IPv6地址使用128位的地址空间，这意味着几乎取之不尽的地址空间。另外IPv6比IPv4还进行了很多的改进与扩充。
IPv6地址  冒分16进制表示法（XXXX:XXXX:XXXX:XXXX:XXXX:XXXX:XXXX:XXXX），每个部分中的0可以省略。比如：2001:0DB8:0000:0023:0008:0800:200C:417A 可以缩写为2001:DB8:0:23:8:800:200C:417A
 0位压缩。如果地址中包含很多连续的0，可以把0压缩为&amp;rdquo;::&amp;ldquo;，并且&amp;rdquo;::&amp;ldquo;只能出现1次。 比如 FF01:0:0:0:0:0:0:1101 可以缩略为 FF01::1101
 内嵌IPv4地址表示法。为了实现IPv4-IPv6互通，IPv4地址会嵌入IPv6地址中，此时地址常表示为：X:X:X:X:X:X:d.d.d.d，前96b采用冒分十六进制表示，而最后32b地址则使用IPv4的点分十进制表示，例如::192.168.0.1与::FFFF:192.168.0.1就是两个典型的例子，注意在前96b中，压缩0位的方法依旧适用。
  IPv6地址分类    地址类型 IPv4 IPv6     单播(unicast) Yes Yes   组播(multicast) Yes Yes   任播(anycast) No Yes   广播 Yes No (通过组播来达到类似目的)    IPv6的地址类型通过地址的前缀进行区别
   IPv6地址类型 前缀标识     Loopback (unicast) ::1&amp;frasl;128   Link local (unicast) FE80::/10   Site local (unicast) FEC0::/10   Global (unicast)    multicast FF00::/8   anycast 从单播地址空间中分配    IPv4 vs IPv6 IPv6比IPv4的优势： 1.</description>
    </item>
    
    <item>
      <title>一行代码让你的字符终端下起雪来！</title>
      <link>https://www.singleye.net/2017/01/%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E8%AE%A9%E4%BD%A0%E7%9A%84%E5%AD%97%E7%AC%A6%E7%BB%88%E7%AB%AF%E4%B8%8B%E8%B5%B7%E9%9B%AA%E6%9D%A5/</link>
      <pubDate>Sun, 15 Jan 2017 22:08:38 +0800</pubDate>
      
      <guid>https://www.singleye.net/2017/01/%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E8%AE%A9%E4%BD%A0%E7%9A%84%E5%AD%97%E7%AC%A6%E7%BB%88%E7%AB%AF%E4%B8%8B%E8%B5%B7%E9%9B%AA%E6%9D%A5/</guid>
      <description>在网上一段shell脚本，虽然只有一行但运行后可以在屏幕上实现下雪的效果，实在让人佩服，决定好好研究一下。
1  for((I=0;J=--I;))do clear;for((D=LINES;S=++J**3%COLUMNS,--D;))do printf %*s.\\n $S;done;sleep .1;done   不过原代码虽然简洁但不太容易一下子看明白工作原理，而且只能在命令行上运行无法保存成脚本文件，所以自己按照理解重新写了一遍： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  #!/bin/sh  rows=$(tput lines) cols=$(tput cols) i=0 while true do clear ((x=i,i++)) for((r=0;r&amp;lt;rows;r++)) do printf &amp;#34;%*s*\n&amp;#34; $((x**3%cols)) ((x--)) done sleep .1 done</description>
    </item>
    
    <item>
      <title>搭建SoftEther VPN 服务</title>
      <link>https://www.singleye.net/2017/01/%E6%90%AD%E5%BB%BAsoftether-vpn-%E6%9C%8D%E5%8A%A1/</link>
      <pubDate>Tue, 10 Jan 2017 15:22:39 +0000</pubDate>
      
      <guid>https://www.singleye.net/2017/01/%E6%90%AD%E5%BB%BAsoftether-vpn-%E6%9C%8D%E5%8A%A1/</guid>
      <description>最近在公司内部架了台服务器给团队的同学们使用，可是在公司外面的时候就没办法再继续访问上面的资源了实在不太方便，虽然利用公司路由器的可以将服务器端口映射出去，但这样做只能访问部分资源，还是搭建一套VPN服务器更加适合所有人的需求。
研究了一下PPP/L2TP，但PPP已经在iOS设备上见不到了，L2TP又对CentOS 7.3支持不友好，后来找到了SoftEther，发现不仅协议支持全面而且支持命令行／图形界面的管理工具，使用和管理都很方便。
搭建方法 通过Local bridge的方式访问远程网络 具体过程可以参照官方文档，这种方法也是我最开始使用的方法，但搭建好之后发现这种连接的设备无法访问搭建VPN的服务器本身，但是我们这台服务器上提供了需要大家访问的资源，因此这对与我们公司来说是无法接受的。原因也可以理解，因为Linux不允许访问Local bridge网络接口对应的IP。具体可以参考官方文档的解释：
 Limitations within the Linux or UNIX operating system prevent communication with IP addresses assigned to the network adapter locally bridged from the VPN side (Virtual Hub side). The cause of this restriction lies with OS&amp;rsquo;s internal kernel codes rather than with the SoftEther VPN. When wishing to communicate in any form with a UNIX computer used for local bridging from the VPN side (Virtual Hub side), (for instance, when running both the VPN Server / VPN Bridge service &amp;amp; the HTTP Server service and wishing to grant access to the server service from the VPN side as well), prepare and connect a local bridge network adapter and physically connect both it and the existing network adapter to the same segment (as explained in 3.</description>
    </item>
    
    <item>
      <title>使用nginx搭建hugo静态blog服务</title>
      <link>https://www.singleye.net/2017/01/%E4%BD%BF%E7%94%A8nginx%E6%90%AD%E5%BB%BAhugo%E9%9D%99%E6%80%81blog%E6%9C%8D%E5%8A%A1/</link>
      <pubDate>Tue, 10 Jan 2017 09:16:36 +0000</pubDate>
      
      <guid>https://www.singleye.net/2017/01/%E4%BD%BF%E7%94%A8nginx%E6%90%AD%E5%BB%BAhugo%E9%9D%99%E6%80%81blog%E6%9C%8D%E5%8A%A1/</guid>
      <description>之前使用过wordpress搭建过内容管理网站，但是运行环境搭建有些复杂而且页面内容创建需要不够方便，后来关注到静态页面网站框架，发现可以使用markdown进行内容编辑，这对于程序猿来说简直再有好不过了！
简单检索了一下静态内容管理的有很多实现，Ruby的Jekyll，Python的Sphinx doc，Go的Hugo，因为最近在学习Go所以决定搭建一个Hugo来研究下。
使用源码部署hugo 部署golang  $ yum install golang  下载hugo源代码  $ wget https://github.com/spf13/hugo/archive/v0.18.1.tar.gz $ tar xf v0.18.1.tar.gz $ cd hugo-0.18.1/ $ export GOPATH=/usr/local/go $ go get -v github.com/spf13/hugo  hugo的基本使用 创建项目  $ /usr/local/go/bin/hugo new site myblogs  创建post  $ /usr/local/go/bin/hugo new post/first.md  使用themes  $ cd themes/ $ git clone https://github.com/kakawait/hugo-tranquilpeak-theme.git $ cp hugo-tranquilpeak-theme/exampleSite/* ..  构造页面  $ cd content $ mkdir archives $ touch archives/_index.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.singleye.net/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.singleye.net/1/01/</guid>
      <description></description>
    </item>
    
    <item>
      <title>SearchEngine</title>
      <link>https://www.singleye.net/1/01/searchengine/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.singleye.net/1/01/searchengine/</guid>
      <description>&lt;!--toc--&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>