<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Cache2 on singleye</title>
    <link>/tags/cache2/</link>
    <description>singleye (Cache2)</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <managingEditor>**Email:** [singleye512@gmail.com](mailto:singleye512@gmail.com) (singleye)</managingEditor>
    <webMaster>**Email:** [singleye512@gmail.com](mailto:singleye512@gmail.com) (singleye)</webMaster>
    <lastBuildDate>Sun, 30 Jun 2019 23:10:02 +0800</lastBuildDate>
    
    <atom:link href="/tags/cache2/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Firefox cache2 数据结构解析</title>
      <link>/2019/06/firefox-cache2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Sun, 30 Jun 2019 23:10:02 +0800</pubDate>
      <author>**Email:** [singleye512@gmail.com](mailto:singleye512@gmail.com) (singleye)</author>
      <guid>/2019/06/firefox-cache2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90/</guid>
      <description>&lt;!--toc--&gt;
&lt;p&gt;开始研究firefox磁盘保存的文件格式源于最近使用selenium做爬虫抓数据时需要下载爬取时的图片碰到的一些问题。&lt;/p&gt;
&lt;p&gt;先简单说一下最开始使用selenium下载图片时摸索出的几个办法：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;方法&lt;/th&gt;
&lt;th&gt;优点&lt;/th&gt;
&lt;th&gt;缺点&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;使用requests包直接访问图片资源并保存成文件&lt;/td&gt;
&lt;td&gt;可以直接下载原始图片文件&lt;/td&gt;
&lt;td&gt;增大网络流量及耗时&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;使用webdriver找到图片元素，调用snapshot()保存图片&lt;/td&gt;
&lt;td&gt;操作简单&lt;/td&gt;
&lt;td&gt;chromedriver工作正常，但firefox的geckodriver下载图片位置存在偏差。图片保存格式为png，并且尺寸有偏差。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;用webdriver在新页面中打开图片，再用snapshot()方法进行保存&lt;/td&gt;
&lt;td&gt;可以解决上面firefox保存图片的问题&lt;/td&gt;
&lt;td&gt;图片格式为png，操作费时&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;找到图片在页面上的具体位置，使用snapshot()针对坐标位置进行截图&lt;/td&gt;
&lt;td&gt;可以解决上面firefox保存图片偏差的问题&lt;/td&gt;
&lt;td&gt;保存格式为png，并且难以控制图片尺寸&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;上面几个方法虽然可以靠时间和后续处理解决问题，但是都不是很好的方法。之后想到了浏览器对图片应该使用缓存进行处理，于是就想是否可以通过查看磁盘上保存的浏览器缓存数据找到需要保存的图片资源。经过一番研究后基本搞明白了firefox的
cache2缓存文件的格式，下面对缓存文件格式做个分析。&lt;/p&gt;
&lt;h1 id=&#34;firefox-cache2-文件目录结构&#34; &gt;
&lt;div&gt;
    &lt;a href=&#34;#firefox-cache2-%e6%96%87%e4%bb%b6%e7%9b%ae%e5%bd%95%e7%bb%93%e6%9e%84&#34;&gt;
        ##
    &lt;/a&gt;
    Firefox cache2 文件目录结构
&lt;/div&gt;
&lt;/h1&gt;
&lt;p&gt;Firefox在用户的profile目录中保存缓存文件结构，可以通过在firefox地址输入框中输入&amp;rsquo;about:profiles&amp;rsquo;查看当前用户的profile目录。&lt;/p&gt;
&lt;p&gt;在profile中找到&amp;rsquo;cache2&amp;rsquo;目录，该目录保存了浏览器的缓存数据。其中主要内容有两个：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&amp;lsquo;index&amp;rsquo;文件：该文件是缓存的索引文件，记录了每一个被缓存在本地磁盘上的缓存文件的基本元信息，比如缓存记录的使用频率、过期时间、文件大小等&amp;hellip;&lt;/li&gt;
&lt;li&gt;&amp;rsquo;entries&amp;rsquo;目录：目录中的每一个文件对应一个被浏览器缓存的数据文件，并且文件使用特定的数据格式存储了相应的元信息，比较重要的信息有URL&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ ls
AlternateServices.txt        cache2                       extensions.json              pkcs11.txt                   startupCache
OfflineCache                 cert9.db                     favicons.sqlite              places.sqlite                storage
SecurityPreloadState.txt     compatibility.ini            formhistory.sqlite           pluginreg.dat                storage-sync.sqlite
SiteSecurityServiceState.txt containers.json              gmp                          prefs.js                     storage.sqlite
TRRBlacklist.txt             content-prefs.sqlite         gmp-gmpopenh264              safebrowsing                 thumbnails
addonStartup.json.lz4        cookies.sqlite               gmp-widevinecdm              saved-telemetry-pings        times.json
addons.json                  crashes                      handlers.json                search.json.mozlz4           weave
blocklist.xml                datareporting                key4.db                      sessionCheckpoints.json      webappsstore.sqlite
bookmarkbackups              extension-preferences.json   minidumps                    sessionstore-backups         webappsstore.sqlite-shm
broadcast-listeners.json     extensions                   permissions.sqlite           sessionstore.jsonlz4         xulstore.json


$ ls cache2/
doomed    entries   index     index.log

$ ls cache2/entries/
017239BD353C39FEF561AD4878BC169D5B89D5FA 5D032C390BFDCC43406BE001CADB00C017762B77 B25D0FBB9AD160F3CA160ED3E26BFF9F0E274929
026860131AC8837A36968B435E640BDD30992E73 5D2DC9AE83B62B8763A0C14BDB89C4C45EFA111D B2BB561C0A27E72044D3AEE5425F4E5A8F0348E2
04465FB4C96F61466B9A67422B84ECC5F3EDEBC6 5E4954707B44E5A4B4ACF5F22B52219A1DCA477F B35B9720DB46BE7509AD4A253DDA32F12CEFFBC8
04978A7A83CF7B8511841F4A26598987807DBC89 5F34A74D1380D10E61240C4B94321E6D5B7812DB B412652745622FCEAC058F3F08A728999A3B4664
04D7BC87034DE29F67E22BAA58D84F3D1C64E15A 5FE950976304D0FC774A22F674AF6B00E8528C88 B4160F7B008034AC71D5F250245DFE39FBEEC360
06B62E73358EF1CBB9F8B4068FB133EE20D83FBF 601487B53548B7563ABB522C9452E066D0E8F82B B428F0BFE97CCBEF8F796B282FAF44664A4B0328
07D9B3A9557270C7517C771711663C8F78019C12 6059AD83AC6E3CFF4FEE798D7BD32709ED3F51DE B45040B5F7F65C61AF516477B393B2C3129BEA9A
0843F8C54EDE9BDFABABDB50655BB7CD89945828 609B40F6174E219E48CD0A82ECF3ADE83FFE90B6 B4E19E0CA4676E3E873F580DB210101AB849FBA6
...
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;缓存index文件格式&#34; &gt;
&lt;div&gt;
    &lt;a href=&#34;#%e7%bc%93%e5%ad%98index%e6%96%87%e4%bb%b6%e6%a0%bc%e5%bc%8f&#34;&gt;
        ##
    &lt;/a&gt;
    缓存index文件格式
&lt;/div&gt;
&lt;/h1&gt;
&lt;p&gt;文件使用Big-endian字节序，文件由1个文件头及后续多个描述缓存文件的数据块构成，每一块描述一个对应的缓存文件。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;偏移&lt;/th&gt;
&lt;th&gt;Size&lt;/th&gt;
&lt;th&gt;内容&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0x0&lt;/td&gt;
&lt;td&gt;12 Bytes&lt;/td&gt;
&lt;td&gt;文件头&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0xC&lt;/td&gt;
&lt;td&gt;36 Bytes&lt;/td&gt;
&lt;td&gt;第一个缓存文件描述块&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0x30&lt;/td&gt;
&lt;td&gt;36 Bytes&lt;/td&gt;
&lt;td&gt;第二个缓存文件描述块&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&amp;hellip;&lt;/td&gt;
&lt;td&gt;&amp;hellip;&lt;/td&gt;
&lt;td&gt;&amp;hellip;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0xC+N*0x24&lt;/td&gt;
&lt;td&gt;36 Bytes&lt;/td&gt;
&lt;td&gt;第N个缓存文件描述块&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;文件头具体结构如下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;偏移&lt;/th&gt;
&lt;th&gt;size&lt;/th&gt;
&lt;th&gt;内容&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0x0&lt;/td&gt;
&lt;td&gt;4 Bytes&lt;/td&gt;
&lt;td&gt;版本号&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0x4&lt;/td&gt;
&lt;td&gt;4 Bytes&lt;/td&gt;
&lt;td&gt;最后一次更新时间戳&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0x8&lt;/td&gt;
&lt;td&gt;4 Bytes&lt;/td&gt;
&lt;td&gt;脏数据标记&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;每一个缓存描述块内部结构如下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;内部偏移&lt;/th&gt;
&lt;th&gt;size&lt;/th&gt;
&lt;th&gt;内容&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0x0&lt;/td&gt;
&lt;td&gt;20 Bytes&lt;/td&gt;
&lt;td&gt;缓存文件key（&amp;rsquo;:&amp;rsquo;+URL）的sha1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0x14&lt;/td&gt;
&lt;td&gt;4 Bytes&lt;/td&gt;
&lt;td&gt;使用频率&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0x18&lt;/td&gt;
&lt;td&gt;4 Bytes&lt;/td&gt;
&lt;td&gt;过期时间&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0x1C&lt;/td&gt;
&lt;td&gt;4 Bytes&lt;/td&gt;
&lt;td&gt;app ID&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0x20&lt;/td&gt;
&lt;td&gt;1 Bytes&lt;/td&gt;
&lt;td&gt;缓存文件flag&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0x21&lt;/td&gt;
&lt;td&gt;3 Bytes&lt;/td&gt;
&lt;td&gt;缓存文件大小&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;缓存文件格式&#34; &gt;
&lt;div&gt;
    &lt;a href=&#34;#%e7%bc%93%e5%ad%98%e6%96%87%e4%bb%b6%e6%a0%bc%e5%bc%8f&#34;&gt;
        ##
    &lt;/a&gt;
    缓存文件格式
&lt;/div&gt;
&lt;/h1&gt;
&lt;p&gt;&amp;lsquo;cache2/entries&amp;rsquo;目录中的每个文件用来记录一个被缓存的文件，文件内容也是Big-endian，文件格式如下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;偏移&lt;/th&gt;
&lt;th&gt;size&lt;/th&gt;
&lt;th&gt;内容&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0x0&lt;/td&gt;
&lt;td&gt;缓存文件大小&lt;/td&gt;
&lt;td&gt;被缓存文件内容&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;紧接着缓存数据&lt;/td&gt;
&lt;td&gt;4+n_chunk*2&lt;/td&gt;
&lt;td&gt;暂时还不清楚其中具体内容，不过文件URL信息不在其中&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;紧接着上面的位置&lt;/td&gt;
&lt;td&gt;可变长度&lt;/td&gt;
&lt;td&gt;被缓存文件元信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;文件最后&lt;/td&gt;
&lt;td&gt;4 Bytes&lt;/td&gt;
&lt;td&gt;被缓存文件内容的尺寸&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;n_chunk的计算方法是“(被缓存文件尺寸+256k-1)/256k”。&lt;/p&gt;
&lt;p&gt;从上面的结构看，解析缓存文件第一步就是从最后4个字节找到缓存文件尺寸，从而找到对应的元信息。元信息中包含了最重要的缓存文件的key ID信息，key ID包含了缓存数据的URL。&lt;/p&gt;
&lt;p&gt;元信息格式：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;内部偏移&lt;/th&gt;
&lt;th&gt;尺寸&lt;/th&gt;
&lt;th&gt;内容&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0x0&lt;/td&gt;
&lt;td&gt;4 Bytes&lt;/td&gt;
&lt;td&gt;版本信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0x4&lt;/td&gt;
&lt;td&gt;4 Bytes&lt;/td&gt;
&lt;td&gt;被获取数量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0x8&lt;/td&gt;
&lt;td&gt;4 Bytes&lt;/td&gt;
&lt;td&gt;上次获取时间戳&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0xC&lt;/td&gt;
&lt;td&gt;4 Bytes&lt;/td&gt;
&lt;td&gt;上次修改时间戳&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0x10&lt;/td&gt;
&lt;td&gt;4 Bytes&lt;/td&gt;
&lt;td&gt;超时时间戳&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0x14&lt;/td&gt;
&lt;td&gt;4 Bytes&lt;/td&gt;
&lt;td&gt;key的字节长度&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0x18&lt;/td&gt;
&lt;td&gt;4 Bytes&lt;/td&gt;
&lt;td&gt;标志位信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0x1C&lt;/td&gt;
&lt;td&gt;0x14中的key尺寸&lt;/td&gt;
&lt;td&gt;key信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&amp;hellip;&lt;/td&gt;
&lt;td&gt;&amp;hellip;&lt;/td&gt;
&lt;td&gt;&amp;hellip;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&amp;hellip;&lt;/td&gt;
&lt;td&gt;&amp;hellip;&lt;/td&gt;
&lt;td&gt;请求信息&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;解析代码&#34; &gt;
&lt;div&gt;
    &lt;a href=&#34;#%e8%a7%a3%e6%9e%90%e4%bb%a3%e7%a0%81&#34;&gt;
        ##
    &lt;/a&gt;
    解析代码
&lt;/div&gt;
&lt;/h1&gt;
&lt;p&gt;做了个简单的cache2缓存文件解析程序：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/singleye/FirefoxCache2&#34;&gt;https://github.com/singleye/FirefoxCache2&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
