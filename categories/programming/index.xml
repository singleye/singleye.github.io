<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Programming on 好奇心是探索未知世界的钥匙</title>
    <link>https://www.singleye.net/categories/programming/</link>
    <description>Recent content in Programming on 好奇心是探索未知世界的钥匙</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Thu, 04 Apr 2024 17:06:50 +0000</lastBuildDate>
    
	<atom:link href="https://www.singleye.net/categories/programming/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>tmux AI 助手</title>
      <link>https://www.singleye.net/2024/04/tmux-ai-%E5%8A%A9%E6%89%8B/</link>
      <pubDate>Thu, 04 Apr 2024 17:06:50 +0000</pubDate>
      
      <guid>https://www.singleye.net/2024/04/tmux-ai-%E5%8A%A9%E6%89%8B/</guid>
      <description>日产开发时很喜欢用 tmux，最近写了一个 tmux 的 AI 插件，这个插件可以使用 ollama 支持的 LLM 生成 shell / 编程相关的内容，会对日常使用 CLI 的同学们带来一些帮助。
使用方法：  + Q 调出命令输入栏，在输入栏中写好问题回车，之后 tmux 会把生成的答案在新的窗口中显示出来。
项目链接： https://github.com/singleye/tmux-ai-helper</description>
    </item>
    
    <item>
      <title>javascript var/let/const 比较</title>
      <link>https://www.singleye.net/2023/12/javascript-var/let/const-%E6%AF%94%E8%BE%83/</link>
      <pubDate>Tue, 12 Dec 2023 23:54:00 +0800</pubDate>
      
      <guid>https://www.singleye.net/2023/12/javascript-var/let/const-%E6%AF%94%E8%BE%83/</guid>
      <description>&lt;!--toc--&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>django-rest-framework 和 simplejwt 的类关系</title>
      <link>https://www.singleye.net/2023/12/django-rest-framework-%E5%92%8C-simplejwt-%E7%9A%84%E7%B1%BB%E5%85%B3%E7%B3%BB/</link>
      <pubDate>Sun, 10 Dec 2023 11:40:29 +0800</pubDate>
      
      <guid>https://www.singleye.net/2023/12/django-rest-framework-%E5%92%8C-simplejwt-%E7%9A%84%E7%B1%BB%E5%85%B3%E7%B3%BB/</guid>
      <description>&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Python 内存管理</title>
      <link>https://www.singleye.net/2023/11/python-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</link>
      <pubDate>Tue, 21 Nov 2023 14:40:28 +0800</pubDate>
      
      <guid>https://www.singleye.net/2023/11/python-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</guid>
      <description>&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>python2 和 python3 的一些区别</title>
      <link>https://www.singleye.net/2018/02/python2-%E5%92%8C-python3-%E7%9A%84%E4%B8%80%E4%BA%9B%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Mon, 26 Feb 2018 23:30:06 +0800</pubDate>
      
      <guid>https://www.singleye.net/2018/02/python2-%E5%92%8C-python3-%E7%9A%84%E4%B8%80%E4%BA%9B%E5%8C%BA%E5%88%AB/</guid>
      <description> python2与python3的区别    区别点 python2 python3     write() 可以直接写utf8内容 写utf8内容碰到：TypeError: write() argument must be str, not bytes解决方法：open(file, &amp;lsquo;wb&amp;rsquo;)   super() super(CLASS_NAME, self).method() super().method()   / 除法运算，结果取整数 除法运算，结果为浮点数，取证书使用“//”   dict has_key()可以用来查询是否存在某个键 has_key()方法不存了，使用&amp;rsquo;key in dictionary&amp;rsquo;来查询(python2也支持该方法)    python3的新特性    新特性 描述 参考     @ 矩阵乘法运算符，目前还没有定义built-in的矩阵数据类型 PEP 465 - A dedicated infix operator for matrix multiplication   / 除法运算，结果浮点数    // 除法运算，结果取整数     </description>
    </item>
    
    <item>
      <title>golang UDP中Read()/ReadFromUDP()/Write()/WriteToUDP()的使用</title>
      <link>https://www.singleye.net/2017/12/golang-udp%E4%B8%ADread/readfromudp/write/writetoudp%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Tue, 05 Dec 2017 15:19:40 +0800</pubDate>
      
      <guid>https://www.singleye.net/2017/12/golang-udp%E4%B8%ADread/readfromudp/write/writetoudp%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
      <description>学习golang进行UDP client/server通讯的过程中发现Read/ReadFromUDP/Write/WriteToUDP的使用有些需要注意之处，这里记录一下。
代码实验 UDP server UDP服务器端在调用&amp;rdquo;net.ListenUDP()&amp;ldquo;后创建&amp;rdquo;net.UDPConn&amp;rdquo;，read/write操作是通过这个UDPConn来完成的。因为listen的时候只指定了本地绑定的地址，它只能被动的接收来自客户端的消息，因此这个UDPConn在golang中为&amp;rsquo;unconnected&amp;rsquo;类型的。
这种类型的UDPConn的读操作可以接受Read()及ReadFromUDP()。区别是Read()无法知道远程连接的地址信息而ReadFromUDP()可以，所以如果后续需要跟远程进行双向通讯需要使用ReadFromUDP()。
这种类型的UDPConn在进行写操作时必须使用WriteToUDP()完成，并且需要指定对方的地址信息。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48  package main import ( &amp;#34;flag&amp;#34; &amp;#34;fmt&amp;#34; &amp;#34;net&amp;#34; &amp;#34;os&amp;#34; ) var host = flag.</description>
    </item>
    
    <item>
      <title>GO语言依赖管理那些事儿</title>
      <link>https://www.singleye.net/2017/12/go%E8%AF%AD%E8%A8%80%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/</link>
      <pubDate>Sat, 02 Dec 2017 18:17:23 +0800</pubDate>
      
      <guid>https://www.singleye.net/2017/12/go%E8%AF%AD%E8%A8%80%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/</guid>
      <description>学习GO开发的过程中发现GO的依赖管理有些不够合理之处。
首先，使用GO开发时在假设项目及依赖关系都通过全系统唯一的GOPATH进行管理，可事实上一个开发人员不可能同时只做一个项目开发，不能假设不同项目的依赖都是一致的。这个问题自从v1.5引入vendor管理方法得到了一定改善。可是go get对vendor支持并不友好，这增加了管理的工作量。很多项目也被开发出来解决这个问题，比如&amp;rsquo;govendor&amp;rsquo;。
引入vendor方法后的项目依赖查找顺序如下：
 首先查找当前包下面的vendor目录 向上一级目录查找，直至找到src目录下的vendor目录 在GOPATH下面查找 在GOROOT下面查找  第二个不合理的地方，虽然引入了vendor目录解决单独项目的局部依赖管理问题，但依然要求把每个项目放入系统全局GOPATH中进行管理。可是一个项目可能只是一个大项目中的一小部分，而整个大项目可能有不同的开发语言构成，那么管理这种混合项目就是一个很麻烦的事情。另外每一个项目本身随着开发时间的推移会出现多个版本，当你在处理一个版本的问题是可能需要临时切换到另一个版本，基于同一个GOPATH目录开发时对于这种切换管理也并不算友好。&amp;rsquo;gb&amp;rsquo;这个项目开发出来后解决了这一问题，但这导致了项目管理必须使用gb工具，就连基本的build也脱离不开这种依赖，这也导致了本人碰到的第三个问题。
第三个不合理之处是对于编辑器的不友好。由于个人的主要编辑器是vim，并且使用了vim-go插件，这个插件支持了Go的开发工具链，可以在vim中方便的使用GoFmt/GoImports/GoBuild/GoTest等这些命令进行开发。但是由于gb对vim的支持欠缺导致在gb创建的项目若不放入标准的GOPATH中有些vim-go的命令执行会出现问题。</description>
    </item>
    
    <item>
      <title>Beego开发入门</title>
      <link>https://www.singleye.net/2017/11/beego%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/</link>
      <pubDate>Thu, 30 Nov 2017 18:04:31 +0800</pubDate>
      
      <guid>https://www.singleye.net/2017/11/beego%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/</guid>
      <description>安装  安装beego：  $ go get github.com/astaxie/beego  安装bee开发工具：  $ go get github.com/beego/bee $ bee Bee is a Fast and Flexible tool for managing your Beego Web Application. USAGE bee command [arguments] AVAILABLE COMMANDS version Prints the current Bee version migrate Runs database migrations api Creates a Beego API application bale Transforms non-Go files to Go source files fix Fixes your application by making it compatible with newer versions of Beego dlv Start a debugging session using Delve dockerize Generates a Dockerfile for your Beego application generate Source code generator hprose Creates an RPC application based on Hprose and Beego frameworks new Creates a Beego application pack Compresses a Beego application into a single file rs Run customized scripts run Run the application by starting a local development server server serving static content over HTTP on port Use bee help [command] for more information about a command.</description>
    </item>
    
    <item>
      <title>Git Submodule使用方法</title>
      <link>https://www.singleye.net/2017/11/git-submodule%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</link>
      <pubDate>Fri, 24 Nov 2017 15:49:02 +0800</pubDate>
      
      <guid>https://www.singleye.net/2017/11/git-submodule%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</guid>
      <description>假设有两个项目project1和project2代码仓库：
$ ls project1/ HEAD branches config description hooks info objects refs $ ls project2/ HEAD branches config description hooks info objects refs 1. 从代码仓库clone开发库p1/p2 $git clone ../project1 p1 Cloning into &amp;#39;p1&amp;#39;... warning: You appear to have cloned an empty repository. done. $ git clone ../project2 p2 Cloning into &amp;#39;p2&amp;#39;... warning: You appear to have cloned an empty repository. done. 2. 对p1/p2做一些改动并且push到原代码仓库 在p1中添加新文件file1并且push到远程库project1
$ touch file1 $ git add file1 $ git commit [master (root-commit) 9132026] Init project 1 with file1 1 file changed, 0 insertions(+), 0 deletions(-) create mode 100644 file1 在p2中添加新文件file2并且push到远程库project2</description>
    </item>
    
    <item>
      <title>Vim 8 Mac</title>
      <link>https://www.singleye.net/2017/11/vim-8-mac/</link>
      <pubDate>Mon, 20 Nov 2017 00:08:15 +0800</pubDate>
      
      <guid>https://www.singleye.net/2017/11/vim-8-mac/</guid>
      <description>安装vim8 $ xcode-select --install $ ./configure --enable-luainterp=yes --enable-perlinterp=yes --enable-pythoninterp=yes --enable-tclinterp=yes --enable-rubyinterp=yes --enable-cscope --with-lua-prefix=/usr/local --enable-terminal --enable-multibyte --with-features=huge $ make $ make install  安装插件 安装YouCompleteMe: $ ./install.py --clang-completer --go-completer --js-completer  vim folding    命令 功能     za 打开/关闭当前的折叠   zc 关闭当前打开的折叠   zo 打开当前的折叠   zm 关闭所有折叠   zM 关闭所有折叠及其嵌套的折叠   zr 打开所有折叠   zR 打开所有折叠及其嵌套的折叠   zd 删除当前折叠   zE 删除所有折叠   zj 移动至下一个折叠   zk 移动至上一个折叠   zn 禁用折叠   zN 启用折叠    Issues macos iTerm启动vim后第一行显示&amp;rsquo;$p&amp;rsquo;字符 解决方法：把终端类型从xterm或者xterm-256color改为linux</description>
    </item>
    
    <item>
      <title>Go语言编程陷阱</title>
      <link>https://www.singleye.net/2017/11/go%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B%E9%99%B7%E9%98%B1/</link>
      <pubDate>Tue, 14 Nov 2017 00:55:51 +0800</pubDate>
      
      <guid>https://www.singleye.net/2017/11/go%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B%E9%99%B7%E9%98%B1/</guid>
      <description>陷阱1: &amp;ldquo;is pointer to interface, not interface&amp;rdquo; 执行下面代码会出现&amp;rdquo;type *net.Conn is pointer to interface, not interface)&amp;ldquo;错误，原因是因为&amp;rdquo;net.Conn&amp;rdquo;是interface而不是struct，不能用指针方式传递。
1 2 3 4 5 6 7 8 9  func connHandler(client *net.Conn) { // do something 	} func somefunc() { // ... 	client, _ := listener.Accept() connHandler(&amp;amp;client) }   GO语言中interface是一种特殊的数据结构，包含两部分内容：
 一个指向方法表的指针 一个指向实际数据的指针  因为这种特殊的数据结构所以interface的指针指向的结构既没有实际数据也没有对应方法，那么就无法直接访问所需的内容，鉴于此原因我推测GO语言的开发者直接屏蔽掉了指向interface指针的用法。这种情况的正确如下：
1 2 3 4 5 6 7 8 9  func connHandler(client net.Conn) { // do something 	} func somefunc() { // .</description>
    </item>
    
    <item>
      <title>GO开发技巧</title>
      <link>https://www.singleye.net/2017/11/go%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/</link>
      <pubDate>Fri, 10 Nov 2017 20:37:07 +0800</pubDate>
      
      <guid>https://www.singleye.net/2017/11/go%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/</guid>
      <description>1. 设置GO语言vim开发环境 在vim中开发GO最好安装相关的插件，比如vim-go这个插件。这个插件除了提供格式化、语法高亮、语法检测等功能以外还有很多方便的功能。
编译命令，对应go build：
:GoBuild  安装，对应go install：
:GoInstall  测试，对应go test：
:GoTest  运行一个单独测试：
:GoTestFunc  覆盖率：
:GoCoverage  运行当前程序，对应go run:
:GoRun  goto符号定义：
:GoDef  文档查询：
:GoDoc :GoDocBrowser  添加／删除包引用：
:GoImport :GoDrop  设置GOPATH：
:GoPath  在结构体增加／删除tag：
:GoAddTags :GoRemoveTags  静态语法检查：
:GoMetaLinter // 调用gometalinter :GoLint // 调用golint  高级代码分析：
:GoImplements :GoCallees :GoReferrers  重命名：
:GoRename  在vim中查询vim-go的帮助文档： :help vim-go  安装完成后打开vim，运行&amp;rdquo;:GoInstallBinaries&amp;rdquo;安装依赖的工具。
再安装其它依赖工具：
// gocode is used by many editors to provide intellisense go get github.</description>
    </item>
    
    <item>
      <title>使用vim进行16进制编辑</title>
      <link>https://www.singleye.net/2017/11/%E4%BD%BF%E7%94%A8vim%E8%BF%9B%E8%A1%8C16%E8%BF%9B%E5%88%B6%E7%BC%96%E8%BE%91/</link>
      <pubDate>Thu, 09 Nov 2017 10:27:00 +0000</pubDate>
      
      <guid>https://www.singleye.net/2017/11/%E4%BD%BF%E7%94%A8vim%E8%BF%9B%E8%A1%8C16%E8%BF%9B%E5%88%B6%E7%BC%96%E8%BE%91/</guid>
      <description>记录一下使用vim编辑二进制文件的方法，这个方法使用了vim执行 &amp;lsquo;%!&amp;rsquo; 来打开外部程序的小技巧。
使用vim打开任意文件，并运行下面命令便进入16禁止编辑模式：
:%!xxd  退出时一定要记得使用下面命令，将编辑的hexdump内容还原成二进制：
:%!xxd -r  使用这个技巧需要注意的是打开二进制文件编辑模式必须使用&amp;rsquo;-b&amp;rsquo;参数，否则vim会在编辑内容末尾增加0x0a字符，保存的时候也就会增加一个字节的信息。
使用&amp;rsquo;-b&amp;rsquo;参数：
00000000: 0011 2233 ..&amp;quot;3  不使用&amp;rsquo;-b&amp;rsquo;参数：
00000000: 0011 2233 0a ..&amp;quot;3.  </description>
    </item>
    
    <item>
      <title>Go语言中new与make的比较</title>
      <link>https://www.singleye.net/2017/11/go%E8%AF%AD%E8%A8%80%E4%B8%ADnew%E4%B8%8Emake%E7%9A%84%E6%AF%94%E8%BE%83/</link>
      <pubDate>Wed, 08 Nov 2017 10:58:00 +0000</pubDate>
      
      <guid>https://www.singleye.net/2017/11/go%E8%AF%AD%E8%A8%80%E4%B8%ADnew%E4%B8%8Emake%E7%9A%84%E6%AF%94%E8%BE%83/</guid>
      <description>go语言new()与make()的区别对于初入golang的开发者来说是个容易混淆的点，这里尝试对这两个的区别做一些总结。
官方文档 首先查找官方文档中的描述，首先是关于&amp;rsquo;new()&amp;lsquo;的：
1 2 3 4  // The new built-in function allocates memory. The first argument is a type, // not a value, and the value returned is a pointer to a newly // allocated zero value of that type. func new(Type) *Type   关于&amp;rsquo;make()&amp;rsquo;:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  // The make built-in function allocates and initializes an object of type // slice, map, or chan (only).</description>
    </item>
    
    <item>
      <title>GO语言中array与slice的比较</title>
      <link>https://www.singleye.net/2017/11/go%E8%AF%AD%E8%A8%80%E4%B8%ADarray%E4%B8%8Eslice%E7%9A%84%E6%AF%94%E8%BE%83/</link>
      <pubDate>Tue, 07 Nov 2017 14:25:00 +0000</pubDate>
      
      <guid>https://www.singleye.net/2017/11/go%E8%AF%AD%E8%A8%80%E4%B8%ADarray%E4%B8%8Eslice%E7%9A%84%E6%AF%94%E8%BE%83/</guid>
      <description>go语言中array与slice的区别总结
    数组array 切片slice 区别     声明定义 var arrayName [arrayLength] dataType var sliceName [] dataType 声明数组需要长度信息，定义slice时不需要   初始化 var arrayName = [arrayLength] dataType {Val1, &amp;hellip; Valn} var arrayName = [&amp;hellip;] dataType {Val1, &amp;hellip; Valn} var sliceName = [] dataType {Val1, &amp;hellip; Valn}var slice [] type = make([] type, length)通过数组初始化：slice := array[:]slice := array[startIndex:endIndex] 初始化数组时需要长度信息，初始化slice时不需要   取值 通过索引index取相应的元素值:arrayName[index] 通过index取元素值：slice[index] 返回一个新切片值: slice[startIndex:endIndex] slice取值除了可以获取一个元素的值外，还可以获取一个新的切片   赋值 元素赋值：array[index] = value  数组赋值： var new_array = array  new_array := array 元素赋值： slice[index] = value 将单个单个值append()到slice中，返回的新slice长度会增加:slice = append(slice, v1, v2&amp;hellip;) 将一个slice copy()到另一个slice中，目标slice长度不变，最多copy截止到目标元素最后一个元素： copy(slice1, slice2)  copy(slice1[si:], slice2) 数组支持简单的单元素或者整体赋值，slice则支持更加精细度的赋值   扩展 不支持 append()，新的slice length和capacity均发生变化： var slice = []int {1, 2, 3, 4, 5}slice = append(slice, 1, 2)fmt.</description>
    </item>
    
    <item>
      <title>python中__main__的作用域及变量使用</title>
      <link>https://www.singleye.net/2017/06/python%E4%B8%AD__main__%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%8F%8A%E5%8F%98%E9%87%8F%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Sat, 10 Jun 2017 23:00:31 +0800</pubDate>
      
      <guid>https://www.singleye.net/2017/06/python%E4%B8%AD__main__%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%8F%8A%E5%8F%98%E9%87%8F%E4%BD%BF%E7%94%A8/</guid>
      <description>今天使用python写一段小程序时发现了一个容易忽略掉的变量作用域的细节。先看一下问题。
$ cat main_variable.py x = 1 if __name__ == &amp;quot;__main__&amp;quot;: global x x = 2 $ python main_area.py main_area.py:4: SyntaxWarning: name &#39;x&#39; is assigned to before global declaration global x  程序的本来目的是在对全局变量前使用global进行声明，但却引发了SyntaxWarning异常。问题原因其实也很简单，因为虽然使用&amp;rsquo;if name == &amp;ldquo;main&amp;rdquo;&amp;lsquo;进行判断后再执行，但代码还是处于整个文件的作用域中，因此并不需要使用global进行声明。
因此程序可以有下面两种改法：
 方法1:  $ cat main_variable.py x = 1 if __name__ == &amp;quot;__main__&amp;quot;: x = 2 $ python main_area.py   方法2:  $ cat main_variable.py x = 1 def main(): global x x = 2 if __name__ == &amp;quot;__main__&amp;quot;: main() $ python main_area.</description>
    </item>
    
    <item>
      <title>numpy学习笔记[1]</title>
      <link>https://www.singleye.net/2017/03/numpy%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/</link>
      <pubDate>Thu, 16 Mar 2017 14:45:31 +0800</pubDate>
      
      <guid>https://www.singleye.net/2017/03/numpy%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/</guid>
      <description>numpy数据结构 基本数据    数据类型 描述     bool 用一个字节存储的布尔类型（True或False）   inti 由所在平台决定其大小的整数（一般为int32或int64）   int8 一个字节大小，-128 至 127   int16 整数，-32768 至 32767   int32 整数，-2 ** 31 至 2 ** 32 -1   int64 整数，-2 ** 63 至 2 ** 63 - 1   uint8 无符号整数，0 至 255   uint16 无符号整数，0 至 65535   uint32 无符号整数，0 至 2 ** 32 - 1   uint64 无符号整数，0 至 2 ** 64 - 1   float16 半精度浮点数：16位，正负号1位，指数5位，精度10位   float32 单精度浮点数：32位，正负号1位，指数8位，精度23位   float64或float 双精度浮点数：64位，正负号1位，指数11位，精度52位   complex64 复数，分别用两个32位浮点数表示实部和虚部   complex128或complex 复数，分别用两个64位浮点数表示实部和虚部    array ‘array’表示元素数据大小固定的同质（相同数据类型）多维度数据。</description>
    </item>
    
    <item>
      <title>一行代码让你的字符终端下起雪来！</title>
      <link>https://www.singleye.net/2017/01/%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E8%AE%A9%E4%BD%A0%E7%9A%84%E5%AD%97%E7%AC%A6%E7%BB%88%E7%AB%AF%E4%B8%8B%E8%B5%B7%E9%9B%AA%E6%9D%A5/</link>
      <pubDate>Sun, 15 Jan 2017 22:08:38 +0800</pubDate>
      
      <guid>https://www.singleye.net/2017/01/%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E8%AE%A9%E4%BD%A0%E7%9A%84%E5%AD%97%E7%AC%A6%E7%BB%88%E7%AB%AF%E4%B8%8B%E8%B5%B7%E9%9B%AA%E6%9D%A5/</guid>
      <description>在网上一段shell脚本，虽然只有一行但运行后可以在屏幕上实现下雪的效果，实在让人佩服，决定好好研究一下。
1  for((I=0;J=--I;))do clear;for((D=LINES;S=++J**3%COLUMNS,--D;))do printf %*s.\\n $S;done;sleep .1;done   不过原代码虽然简洁但不太容易一下子看明白工作原理，而且只能在命令行上运行无法保存成脚本文件，所以自己按照理解重新写了一遍： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  #!/bin/sh  rows=$(tput lines) cols=$(tput cols) i=0 while true do clear ((x=i,i++)) for((r=0;r&amp;lt;rows;r++)) do printf &amp;#34;%*s*\n&amp;#34; $((x**3%cols)) ((x--)) done sleep .1 done</description>
    </item>
    
  </channel>
</rss>