<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Network on singleye</title>
    <link>/categories/network/</link>
    <description>singleye (Network)</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <managingEditor>**Email:** [singleye512@gmail.com](mailto:singleye512@gmail.com) (singleye)</managingEditor>
    <webMaster>**Email:** [singleye512@gmail.com](mailto:singleye512@gmail.com) (singleye)</webMaster>
    <lastBuildDate>Sun, 01 Sep 2019 15:28:41 +0800</lastBuildDate>
    
    <atom:link href="/categories/network/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>ssh代理方法</title>
      <link>/2019/09/ssh%E4%BB%A3%E7%90%86%E6%96%B9%E6%B3%95/</link>
      <pubDate>Sun, 01 Sep 2019 15:28:41 +0800</pubDate>
      <author>**Email:** [singleye512@gmail.com](mailto:singleye512@gmail.com) (singleye)</author>
      <guid>/2019/09/ssh%E4%BB%A3%E7%90%86%E6%96%B9%E6%B3%95/</guid>
      <description>&lt;!--toc--&gt;
&lt;h1 id=&#34;socks-代理&#34; &gt;
&lt;div&gt;
    &lt;a href=&#34;#socks-%e4%bb%a3%e7%90%86&#34;&gt;
        ##
    &lt;/a&gt;
    SOCKS 代理
&lt;/div&gt;
&lt;/h1&gt;
&lt;p&gt;在本地打开 11087 端口，通过该端口可以使用 socks4/socks5 协议连接到目标机（1.2.3.4）&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;alias proxy=&amp;#39;ssh -D 11087 -fnqN user@1.2.3.4&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;ssh-反向连接&#34; &gt;
&lt;div&gt;
    &lt;a href=&#34;#ssh-%e5%8f%8d%e5%90%91%e8%bf%9e%e6%8e%a5&#34;&gt;
        ##
    &lt;/a&gt;
    ssh 反向连接
&lt;/div&gt;
&lt;/h1&gt;
&lt;p&gt;当不方便从外连接到内部网络的机器时可以在内部机器上使用反向连接的方式连接到的方式打通外部机器到内部机器的 ssh 通道&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;ssh -p 22 -qngNTR 10000:localhost:22 proxyuser@proxynode
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;ssh-反向连接时建立-socks-代理&#34; &gt;
&lt;div&gt;
    &lt;a href=&#34;#ssh-%e5%8f%8d%e5%90%91%e8%bf%9e%e6%8e%a5%e6%97%b6%e5%bb%ba%e7%ab%8b-socks-%e4%bb%a3%e7%90%86&#34;&gt;
        #
    &lt;/a&gt;
    ssh 反向连接时建立 SOCKS 代理
&lt;/div&gt;
&lt;/h2&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;ssh -p 10000 -qngfNTD 6767 nodeuser@localhost
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;ssh-传递连接&#34; &gt;
&lt;div&gt;
    &lt;a href=&#34;#ssh-%e4%bc%a0%e9%80%92%e8%bf%9e%e6%8e%a5&#34;&gt;
        #
    &lt;/a&gt;
    ssh 传递连接
&lt;/div&gt;
&lt;/h2&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;ssh -qngfNT -L localhost:6868:localhost:6767 proxyuser@proxynode
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;将本机的 6868 端口接收到的数据发送到 proxynode 机器所在的 localhost:6767 端口，因为 6767 是 SOCK5 反向连接到了另一台机器，因此 6868 的流量实际被发到了另外的那一台机器上。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Firefox cache2 数据结构解析</title>
      <link>/2019/06/firefox-cache2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Sun, 30 Jun 2019 23:10:02 +0800</pubDate>
      <author>**Email:** [singleye512@gmail.com](mailto:singleye512@gmail.com) (singleye)</author>
      <guid>/2019/06/firefox-cache2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90/</guid>
      <description>&lt;!--toc--&gt;
&lt;p&gt;开始研究firefox磁盘保存的文件格式源于最近使用selenium做爬虫抓数据时需要下载爬取时的图片碰到的一些问题。&lt;/p&gt;
&lt;p&gt;先简单说一下最开始使用selenium下载图片时摸索出的几个办法：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;方法&lt;/th&gt;
&lt;th&gt;优点&lt;/th&gt;
&lt;th&gt;缺点&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;使用requests包直接访问图片资源并保存成文件&lt;/td&gt;
&lt;td&gt;可以直接下载原始图片文件&lt;/td&gt;
&lt;td&gt;增大网络流量及耗时&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;使用webdriver找到图片元素，调用snapshot()保存图片&lt;/td&gt;
&lt;td&gt;操作简单&lt;/td&gt;
&lt;td&gt;chromedriver工作正常，但firefox的geckodriver下载图片位置存在偏差。图片保存格式为png，并且尺寸有偏差。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;用webdriver在新页面中打开图片，再用snapshot()方法进行保存&lt;/td&gt;
&lt;td&gt;可以解决上面firefox保存图片的问题&lt;/td&gt;
&lt;td&gt;图片格式为png，操作费时&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;找到图片在页面上的具体位置，使用snapshot()针对坐标位置进行截图&lt;/td&gt;
&lt;td&gt;可以解决上面firefox保存图片偏差的问题&lt;/td&gt;
&lt;td&gt;保存格式为png，并且难以控制图片尺寸&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;上面几个方法虽然可以靠时间和后续处理解决问题，但是都不是很好的方法。之后想到了浏览器对图片应该使用缓存进行处理，于是就想是否可以通过查看磁盘上保存的浏览器缓存数据找到需要保存的图片资源。经过一番研究后基本搞明白了firefox的
cache2缓存文件的格式，下面对缓存文件格式做个分析。&lt;/p&gt;
&lt;h1 id=&#34;firefox-cache2-文件目录结构&#34; &gt;
&lt;div&gt;
    &lt;a href=&#34;#firefox-cache2-%e6%96%87%e4%bb%b6%e7%9b%ae%e5%bd%95%e7%bb%93%e6%9e%84&#34;&gt;
        ##
    &lt;/a&gt;
    Firefox cache2 文件目录结构
&lt;/div&gt;
&lt;/h1&gt;
&lt;p&gt;Firefox在用户的profile目录中保存缓存文件结构，可以通过在firefox地址输入框中输入&amp;rsquo;about:profiles&amp;rsquo;查看当前用户的profile目录。&lt;/p&gt;
&lt;p&gt;在profile中找到&amp;rsquo;cache2&amp;rsquo;目录，该目录保存了浏览器的缓存数据。其中主要内容有两个：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&amp;lsquo;index&amp;rsquo;文件：该文件是缓存的索引文件，记录了每一个被缓存在本地磁盘上的缓存文件的基本元信息，比如缓存记录的使用频率、过期时间、文件大小等&amp;hellip;&lt;/li&gt;
&lt;li&gt;&amp;rsquo;entries&amp;rsquo;目录：目录中的每一个文件对应一个被浏览器缓存的数据文件，并且文件使用特定的数据格式存储了相应的元信息，比较重要的信息有URL&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ ls
AlternateServices.txt        cache2                       extensions.json              pkcs11.txt                   startupCache
OfflineCache                 cert9.db                     favicons.sqlite              places.sqlite                storage
SecurityPreloadState.txt     compatibility.ini            formhistory.sqlite           pluginreg.dat                storage-sync.sqlite
SiteSecurityServiceState.txt containers.json              gmp                          prefs.js                     storage.sqlite
TRRBlacklist.txt             content-prefs.sqlite         gmp-gmpopenh264              safebrowsing                 thumbnails
addonStartup.json.lz4        cookies.sqlite               gmp-widevinecdm              saved-telemetry-pings        times.json
addons.json                  crashes                      handlers.json                search.json.mozlz4           weave
blocklist.xml                datareporting                key4.db                      sessionCheckpoints.json      webappsstore.sqlite
bookmarkbackups              extension-preferences.json   minidumps                    sessionstore-backups         webappsstore.sqlite-shm
broadcast-listeners.json     extensions                   permissions.sqlite           sessionstore.jsonlz4         xulstore.json


$ ls cache2/
doomed    entries   index     index.log

$ ls cache2/entries/
017239BD353C39FEF561AD4878BC169D5B89D5FA 5D032C390BFDCC43406BE001CADB00C017762B77 B25D0FBB9AD160F3CA160ED3E26BFF9F0E274929
026860131AC8837A36968B435E640BDD30992E73 5D2DC9AE83B62B8763A0C14BDB89C4C45EFA111D B2BB561C0A27E72044D3AEE5425F4E5A8F0348E2
04465FB4C96F61466B9A67422B84ECC5F3EDEBC6 5E4954707B44E5A4B4ACF5F22B52219A1DCA477F B35B9720DB46BE7509AD4A253DDA32F12CEFFBC8
04978A7A83CF7B8511841F4A26598987807DBC89 5F34A74D1380D10E61240C4B94321E6D5B7812DB B412652745622FCEAC058F3F08A728999A3B4664
04D7BC87034DE29F67E22BAA58D84F3D1C64E15A 5FE950976304D0FC774A22F674AF6B00E8528C88 B4160F7B008034AC71D5F250245DFE39FBEEC360
06B62E73358EF1CBB9F8B4068FB133EE20D83FBF 601487B53548B7563ABB522C9452E066D0E8F82B B428F0BFE97CCBEF8F796B282FAF44664A4B0328
07D9B3A9557270C7517C771711663C8F78019C12 6059AD83AC6E3CFF4FEE798D7BD32709ED3F51DE B45040B5F7F65C61AF516477B393B2C3129BEA9A
0843F8C54EDE9BDFABABDB50655BB7CD89945828 609B40F6174E219E48CD0A82ECF3ADE83FFE90B6 B4E19E0CA4676E3E873F580DB210101AB849FBA6
...
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;缓存index文件格式&#34; &gt;
&lt;div&gt;
    &lt;a href=&#34;#%e7%bc%93%e5%ad%98index%e6%96%87%e4%bb%b6%e6%a0%bc%e5%bc%8f&#34;&gt;
        ##
    &lt;/a&gt;
    缓存index文件格式
&lt;/div&gt;
&lt;/h1&gt;
&lt;p&gt;文件使用Big-endian字节序，文件由1个文件头及后续多个描述缓存文件的数据块构成，每一块描述一个对应的缓存文件。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;偏移&lt;/th&gt;
&lt;th&gt;Size&lt;/th&gt;
&lt;th&gt;内容&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0x0&lt;/td&gt;
&lt;td&gt;12 Bytes&lt;/td&gt;
&lt;td&gt;文件头&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0xC&lt;/td&gt;
&lt;td&gt;36 Bytes&lt;/td&gt;
&lt;td&gt;第一个缓存文件描述块&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0x30&lt;/td&gt;
&lt;td&gt;36 Bytes&lt;/td&gt;
&lt;td&gt;第二个缓存文件描述块&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&amp;hellip;&lt;/td&gt;
&lt;td&gt;&amp;hellip;&lt;/td&gt;
&lt;td&gt;&amp;hellip;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0xC+N*0x24&lt;/td&gt;
&lt;td&gt;36 Bytes&lt;/td&gt;
&lt;td&gt;第N个缓存文件描述块&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;文件头具体结构如下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;偏移&lt;/th&gt;
&lt;th&gt;size&lt;/th&gt;
&lt;th&gt;内容&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0x0&lt;/td&gt;
&lt;td&gt;4 Bytes&lt;/td&gt;
&lt;td&gt;版本号&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0x4&lt;/td&gt;
&lt;td&gt;4 Bytes&lt;/td&gt;
&lt;td&gt;最后一次更新时间戳&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0x8&lt;/td&gt;
&lt;td&gt;4 Bytes&lt;/td&gt;
&lt;td&gt;脏数据标记&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;每一个缓存描述块内部结构如下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;内部偏移&lt;/th&gt;
&lt;th&gt;size&lt;/th&gt;
&lt;th&gt;内容&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0x0&lt;/td&gt;
&lt;td&gt;20 Bytes&lt;/td&gt;
&lt;td&gt;缓存文件key（&amp;rsquo;:&amp;rsquo;+URL）的sha1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0x14&lt;/td&gt;
&lt;td&gt;4 Bytes&lt;/td&gt;
&lt;td&gt;使用频率&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0x18&lt;/td&gt;
&lt;td&gt;4 Bytes&lt;/td&gt;
&lt;td&gt;过期时间&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0x1C&lt;/td&gt;
&lt;td&gt;4 Bytes&lt;/td&gt;
&lt;td&gt;app ID&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0x20&lt;/td&gt;
&lt;td&gt;1 Bytes&lt;/td&gt;
&lt;td&gt;缓存文件flag&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0x21&lt;/td&gt;
&lt;td&gt;3 Bytes&lt;/td&gt;
&lt;td&gt;缓存文件大小&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;缓存文件格式&#34; &gt;
&lt;div&gt;
    &lt;a href=&#34;#%e7%bc%93%e5%ad%98%e6%96%87%e4%bb%b6%e6%a0%bc%e5%bc%8f&#34;&gt;
        ##
    &lt;/a&gt;
    缓存文件格式
&lt;/div&gt;
&lt;/h1&gt;
&lt;p&gt;&amp;lsquo;cache2/entries&amp;rsquo;目录中的每个文件用来记录一个被缓存的文件，文件内容也是Big-endian，文件格式如下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;偏移&lt;/th&gt;
&lt;th&gt;size&lt;/th&gt;
&lt;th&gt;内容&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0x0&lt;/td&gt;
&lt;td&gt;缓存文件大小&lt;/td&gt;
&lt;td&gt;被缓存文件内容&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;紧接着缓存数据&lt;/td&gt;
&lt;td&gt;4+n_chunk*2&lt;/td&gt;
&lt;td&gt;暂时还不清楚其中具体内容，不过文件URL信息不在其中&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;紧接着上面的位置&lt;/td&gt;
&lt;td&gt;可变长度&lt;/td&gt;
&lt;td&gt;被缓存文件元信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;文件最后&lt;/td&gt;
&lt;td&gt;4 Bytes&lt;/td&gt;
&lt;td&gt;被缓存文件内容的尺寸&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;n_chunk的计算方法是“(被缓存文件尺寸+256k-1)/256k”。&lt;/p&gt;
&lt;p&gt;从上面的结构看，解析缓存文件第一步就是从最后4个字节找到缓存文件尺寸，从而找到对应的元信息。元信息中包含了最重要的缓存文件的key ID信息，key ID包含了缓存数据的URL。&lt;/p&gt;
&lt;p&gt;元信息格式：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;内部偏移&lt;/th&gt;
&lt;th&gt;尺寸&lt;/th&gt;
&lt;th&gt;内容&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0x0&lt;/td&gt;
&lt;td&gt;4 Bytes&lt;/td&gt;
&lt;td&gt;版本信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0x4&lt;/td&gt;
&lt;td&gt;4 Bytes&lt;/td&gt;
&lt;td&gt;被获取数量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0x8&lt;/td&gt;
&lt;td&gt;4 Bytes&lt;/td&gt;
&lt;td&gt;上次获取时间戳&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0xC&lt;/td&gt;
&lt;td&gt;4 Bytes&lt;/td&gt;
&lt;td&gt;上次修改时间戳&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0x10&lt;/td&gt;
&lt;td&gt;4 Bytes&lt;/td&gt;
&lt;td&gt;超时时间戳&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0x14&lt;/td&gt;
&lt;td&gt;4 Bytes&lt;/td&gt;
&lt;td&gt;key的字节长度&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0x18&lt;/td&gt;
&lt;td&gt;4 Bytes&lt;/td&gt;
&lt;td&gt;标志位信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0x1C&lt;/td&gt;
&lt;td&gt;0x14中的key尺寸&lt;/td&gt;
&lt;td&gt;key信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&amp;hellip;&lt;/td&gt;
&lt;td&gt;&amp;hellip;&lt;/td&gt;
&lt;td&gt;&amp;hellip;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&amp;hellip;&lt;/td&gt;
&lt;td&gt;&amp;hellip;&lt;/td&gt;
&lt;td&gt;请求信息&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;解析代码&#34; &gt;
&lt;div&gt;
    &lt;a href=&#34;#%e8%a7%a3%e6%9e%90%e4%bb%a3%e7%a0%81&#34;&gt;
        ##
    &lt;/a&gt;
    解析代码
&lt;/div&gt;
&lt;/h1&gt;
&lt;p&gt;做了个简单的cache2缓存文件解析程序：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/singleye/FirefoxCache2&#34;&gt;https://github.com/singleye/FirefoxCache2&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Nginx Static</title>
      <link>/2017/12/nginx-static/</link>
      <pubDate>Sat, 23 Dec 2017 19:41:39 +0800</pubDate>
      <author>**Email:** [singleye512@gmail.com](mailto:singleye512@gmail.com) (singleye)</author>
      <guid>/2017/12/nginx-static/</guid>
      <description>&lt;p&gt;nginx配置静态文件服务器&lt;/p&gt;
&lt;h1 id=&#34;搭建文件服务器&#34; &gt;
&lt;div&gt;
    &lt;a href=&#34;#%e6%90%ad%e5%bb%ba%e6%96%87%e4%bb%b6%e6%9c%8d%e5%8a%a1%e5%99%a8&#34;&gt;
        ##
    &lt;/a&gt;
    搭建文件服务器
&lt;/div&gt;
&lt;/h1&gt;
&lt;p&gt;要点就是root目录,会自动指向索引文件 如： index, index.html等&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;server {
        client_max_body_size 4G;
        listen  80;  ## listen for ipv4; this line is default and implied
        server_name static.test.sdk.iwplay.com.tw;
        root /home/mini/Sync;
        location / {
        }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;建立索引&#34; &gt;
&lt;div&gt;
    &lt;a href=&#34;#%e5%bb%ba%e7%ab%8b%e7%b4%a2%e5%bc%95&#34;&gt;
        ##
    &lt;/a&gt;
    建立索引
&lt;/div&gt;
&lt;/h1&gt;
&lt;p&gt;建立目录索引也同样如此，不要带索引名称之类的文件，否则会直接显示文件，而不是目录&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;server {
        client_max_body_size 4G;
        listen  80;  ## listen for ipv4; this line is default and implied
        server_name static.test.sdk.iwplay.com.tw;
        root /home/mini/Sync;
     location / {
         autoindex on; //显示索引
         autoindex_exact_size on; //显示大小
         autoindex_localtime on;   //显示时间
        }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;设置密码&#34; &gt;
&lt;div&gt;
    &lt;a href=&#34;#%e8%ae%be%e7%bd%ae%e5%af%86%e7%a0%81&#34;&gt;
        ##
    &lt;/a&gt;
    设置密码
&lt;/div&gt;
&lt;/h1&gt;
&lt;p&gt;搭建文件服务器有时候不想让别人任意访问，想做成一个私有的该怎么办呢，这个时候我们可以用到nginx自带的认证模块。 同样关键的是auth_basic/auth_basic_user_file字段&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;server {
        client_max_body_size 4G;
        listen  80;  ## listen for ipv4; this line is default and implied
        server_name static.test.sdk.iwplay.com.tw;
    root /home/mini/Sync;
     location / {
              auth_basic   &amp;quot;Restricted&amp;quot;;  
              auth_basic_user_file /etc/nginx/pass_file;
              autoindex on;
              autoindex_exact_size on;
              autoindex_localtime on;  
        }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;auth_basic表示的输入密码时的提示语&lt;/li&gt;
&lt;li&gt;auth_basic_user_file则显示认证时的用户密码文件存放路径&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;生成用户密码&#34; &gt;
&lt;div&gt;
    &lt;a href=&#34;#%e7%94%9f%e6%88%90%e7%94%a8%e6%88%b7%e5%af%86%e7%a0%81&#34;&gt;
        ##
    &lt;/a&gt;
    生成用户密码
&lt;/div&gt;
&lt;/h1&gt;
&lt;p&gt;上文实现了用户认证，那么如何添加用户呢。nginx自带了一个功能，如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;htpasswd -c -d /etc/nginx/pass_file username
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样就在/etc/nginx/pass_file 中添加了了一个用户&lt;/p&gt;
&lt;h1 id=&#34;开启压缩&#34; &gt;
&lt;div&gt;
    &lt;a href=&#34;#%e5%bc%80%e5%90%af%e5%8e%8b%e7%bc%a9&#34;&gt;
        ##
    &lt;/a&gt;
    开启压缩
&lt;/div&gt;
&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;server {
  client_max_body_size 4G;
  listen  80;  ## listen for ipv4; this line is default and implied
  server_name static.test.sdk.iwplay.com.tw;
  root /home/mini/Sync;
  
  # new config lines for gzip
  gzip on;
  gzip_min_length 1k;
  gzip_buffers 4 8k;
  gzip_http_version 1.1;
  gzip_types text/plain application/javascript application/x-javascript text/javascript text/css application/xml;
   
   location / {
       auth_basic   &amp;quot;Restricted&amp;quot;;  
       auth_basic_user_file /etc/nginx/pass_file;
       autoindex on;
       autoindex_exact_size on;
       autoindex_localtime on;  
   }
}&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>用scrapy爬取京东商品信息</title>
      <link>/2017/08/%E7%94%A8scrapy%E7%88%AC%E5%8F%96%E4%BA%AC%E4%B8%9C%E5%95%86%E5%93%81%E4%BF%A1%E6%81%AF/</link>
      <pubDate>Thu, 31 Aug 2017 09:46:00 +0000</pubDate>
      <author>**Email:** [singleye512@gmail.com](mailto:singleye512@gmail.com) (singleye)</author>
      <guid>/2017/08/%E7%94%A8scrapy%E7%88%AC%E5%8F%96%E4%BA%AC%E4%B8%9C%E5%95%86%E5%93%81%E4%BF%A1%E6%81%AF/</guid>
      <description>&lt;!-- more /--&gt;
&lt;p&gt;scrapy是一个非常著名的爬虫框架，使用这个框架可以非常容易的生成一个网站爬虫程序框架，之后就可以在框架之上方便的进行爬虫的编写。&lt;/p&gt;
&lt;p&gt;进来想要了解一些产品的市场信息，就用scrapy写了个简单的爬虫，写个笔记记录一下。&lt;/p&gt;
&lt;h1 id=&#34;安装&#34; &gt;
&lt;div&gt;
    &lt;a href=&#34;#%e5%ae%89%e8%a3%85&#34;&gt;
        ##
    &lt;/a&gt;
    安装
&lt;/div&gt;
&lt;/h1&gt;
&lt;p&gt;使用python环境的话最好通过pip进行安装，这样操作简单方便，直接使用下面的命令即可：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ pip install scrapy
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;scrapy框架提供了&amp;rsquo;scrapy&amp;rsquo;命令进行项目的创建及运行管理，所以首先看一下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ scrapy --help
Scrapy 1.4.0 - no active project

Usage:
  scrapy &amp;lt;command&amp;gt; [options] [args]

Available commands:
  bench         Run quick benchmark test
  fetch         Fetch a URL using the Scrapy downloader
  genspider     Generate new spider using pre-defined templates
  runspider     Run a self-contained spider (without creating a project)
  settings      Get settings values
  shell         Interactive scraping console
  startproject  Create new project
  version       Print Scrapy version
  view          Open URL in browser, as seen by Scrapy

  [ more ]      More commands available when run from project directory

Use &amp;quot;scrapy &amp;lt;command&amp;gt; -h&amp;quot; to see more info about a command
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;创建项目&#34; &gt;
&lt;div&gt;
    &lt;a href=&#34;#%e5%88%9b%e5%bb%ba%e9%a1%b9%e7%9b%ae&#34;&gt;
        ##
    &lt;/a&gt;
    创建项目
&lt;/div&gt;
&lt;/h1&gt;
&lt;p&gt;首先使用&amp;rsquo;scrapy startproject&amp;rsquo;创建项目&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ scrapy startproject crawler
New Scrapy project &#39;crawler&#39;, using template directory &#39;/Users/wangq/virtualenv/test/lib/python2.7/site-packages/scrapy/templates/project&#39;, created in:
    /Users/wangq/tmp/crawler

You can start your first spider with:
    cd crawler
    scrapy genspider example example.com
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用&amp;rsquo;scrapy genspider&amp;rsquo;创建爬虫&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cd crawler
$ scrapy genspider jd list.jd.com
$ ls crawler/spiders/jd.py
crawler/spiders/jd.py
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;到此爬虫的框架就创建好了，爬虫的主要代码需要在jd.py中完成。&lt;/p&gt;
&lt;h1 id=&#34;编写爬虫&#34; &gt;
&lt;div&gt;
    &lt;a href=&#34;#%e7%bc%96%e5%86%99%e7%88%ac%e8%99%ab&#34;&gt;
        ##
    &lt;/a&gt;
    编写爬虫
&lt;/div&gt;
&lt;/h1&gt;
&lt;h2 id=&#34;爬虫代码框架&#34; &gt;
&lt;div&gt;
    &lt;a href=&#34;#%e7%88%ac%e8%99%ab%e4%bb%a3%e7%a0%81%e6%a1%86%e6%9e%b6&#34;&gt;
        #
    &lt;/a&gt;
    爬虫代码框架
&lt;/div&gt;
&lt;/h2&gt;
&lt;p&gt;爬虫的代码主要是在crawler/spiders/jd.py中，打开这个文件看到内容如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# -*- coding: utf-8 -*-
import scrapy


class JdSpider(scrapy.Spider):
    name = &#39;jd&#39;
    allowed_domains = [&#39;list.jd.com&#39;]
    start_urls = [&#39;http://list.jd.com/&#39;]

    def parse(self, response):
        pass
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;简单解释下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;name: 爬虫的名字&lt;/li&gt;
&lt;li&gt;allowed_domains: 当时用了OffsiteMiddleware的时候这个配置可以限定爬虫爬取的站点的域名列表&lt;/li&gt;
&lt;li&gt;start_urls: 指定爬虫开始运行时的爬取URL&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在生成的代码中有一个parse()方法，每当爬虫获取一个新的页面爬去返回数据的时候就把这个数据通过response传递给parse()方法进行内容处理。&lt;/p&gt;
&lt;h2 id=&#34;了解要爬取网页的结构&#34; &gt;
&lt;div&gt;
    &lt;a href=&#34;#%e4%ba%86%e8%a7%a3%e8%a6%81%e7%88%ac%e5%8f%96%e7%bd%91%e9%a1%b5%e7%9a%84%e7%bb%93%e6%9e%84&#34;&gt;
        #
    &lt;/a&gt;
    了解要爬取网页的结构
&lt;/div&gt;
&lt;/h2&gt;
&lt;p&gt;编写爬虫前先了解被爬取网页的结构信息，以及信息提取方法。这次我需要提取的信息主要是商品列表页面中的物品、价格、评论数这些基本信息，使用浏览器开发者功能查看对应的元素。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://singleye-public-read.oss-cn-shanghai.aliyuncs.com/singleye.net/static/2017/08/scrapy/scrapy-001.png?x-oss-process=style/png2jpg&#34; alt=&#34;page structure&#34;&gt;&lt;/p&gt;
&lt;p&gt;分析页面发现需要的条目的class都有&amp;rsquo;j-sku-item&amp;rsquo;属性值，知道这个规律后页就可以使用xpath获取到这个条目的具体内容了。&lt;/p&gt;
&lt;h2 id=&#34;通过xpath获取选取的页面元素&#34; &gt;
&lt;div&gt;
    &lt;a href=&#34;#%e9%80%9a%e8%bf%87xpath%e8%8e%b7%e5%8f%96%e9%80%89%e5%8f%96%e7%9a%84%e9%a1%b5%e9%9d%a2%e5%85%83%e7%b4%a0&#34;&gt;
        #
    &lt;/a&gt;
    通过xpath获取选取的页面元素
&lt;/div&gt;
&lt;/h2&gt;
&lt;p&gt;每个div的class属性包含&amp;rsquo;j-sku-item&amp;rsquo;的元素可以通过xpath的这条规则来描述&amp;quot;//div[contains(@class, &amp;lsquo;j-sku-item&amp;rsquo;)]&amp;quot;，scrapy的response可以直接支持xpath，那么想要获取这个对应的元素就可以通过这行代码来获取了：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;response.xpath(&amp;quot;//div[contains(@class, &#39;j-sku-item&#39;)]&amp;quot;):
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;获取价格及评论信息&#34; &gt;
&lt;div&gt;
    &lt;a href=&#34;#%e8%8e%b7%e5%8f%96%e4%bb%b7%e6%a0%bc%e5%8f%8a%e8%af%84%e8%ae%ba%e4%bf%a1%e6%81%af&#34;&gt;
        #
    &lt;/a&gt;
    获取价格及评论信息
&lt;/div&gt;
&lt;/h2&gt;
&lt;p&gt;通常的静态内容网站数据都可以使用xpath来获取，但在爬京东的网站过程中发现价格及评论数据不是后端与页面一起处理好之后一起发送过来的，所以这两个信息无法使用xpath获取，但仔细分析网络请求可以发现这些信息是通过两个web调用来获取的，我们可以使用python的requests库来获取。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;获取评论信息的调用：
&lt;img src=&#34;http://singleye-public-read.oss-cn-shanghai.aliyuncs.com/singleye.net/static/2017/08/scrapy/scrapy-002.jpeg?x-oss-process=style/png2jpg&#34; alt=&#34;comments信息&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接下来可以使用curl来尝试获取评论信息的方法，最终发现访问可以通过类似的简化来完成：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;https://club.jd.com/comment/productCommentSummaries.action?my=pinglun&amp;amp;referenceIds=959228,1722097,1722101
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;主要参数是referenceIds，这里可以指定需要获取的sku的列表。获取的代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def get_comments(sku_id_list):
    &amp;quot;&amp;quot;&amp;quot;
    url: https://club.jd.com/comment/productCommentSummaries.action?my=pinglun&amp;amp;referenceIds=959228,1722097,1722101&amp;quot;
    &amp;quot;&amp;quot;&amp;quot;
    ids = &#39;,&#39;.join(sku_id_list)
    url = &amp;quot;https://club.jd.com/comment/productCommentSummaries.action?my=pinglun&amp;amp;referenceIds=&amp;quot; + ids
    rsp = requests.get(url)
    return rsp.json()
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;获取价格信息的调用：
&lt;img src=&#34;http://singleye-public-read.oss-cn-shanghai.aliyuncs.com/singleye.net/static/2017/08/scrapy/scrapy-003.jpeg?x-oss-process=style/png2jpg&#34; alt=&#34;price信息&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;与获取评论信息类似，最终发现调用的接口可以简化成这个样子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;https://p.3.cn/prices/mgets?skuIds=J_959228%2CJ_1722101%2CJ_2064343
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;不同之处是每个sku前面加了一个&amp;quot;J_&amp;ldquo;字段。参照获取评论的方法代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def get_prices(sku_id_list):
    &amp;quot;&amp;quot;&amp;quot;
    url: https://p.3.cn/prices/mgets?skuIds=J_959228%2CJ_1722101%2CJ_2064343
    &amp;quot;&amp;quot;&amp;quot;
    str_id_list = map(lambda x: &amp;quot;J_&amp;quot;+x, sku_id_list)
    ids = &#39;,&#39;.join(str_id_list)
    url = &amp;quot;https://p.3.cn/prices/mgets?skuIds=&amp;quot; + ids
    rsp = requests.get(url)
    return rsp.json()
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;分页处理&#34; &gt;
&lt;div&gt;
    &lt;a href=&#34;#%e5%88%86%e9%a1%b5%e5%a4%84%e7%90%86&#34;&gt;
        #
    &lt;/a&gt;
    分页处理
&lt;/div&gt;
&lt;/h2&gt;
&lt;p&gt;京东的商品条目很多的时候会分页展示，需要爬虫识别分页信息并自动抓取进行上面的处理。&lt;/p&gt;
&lt;p&gt;首先先找到如何导向下一页的连接：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://singleye-public-read.oss-cn-shanghai.aliyuncs.com/singleye.net/static/2017/08/scrapy/scrapy-004.png?x-oss-process=style/png2jpg&#34; alt=&#34;分页链接&#34;&gt;&lt;/p&gt;
&lt;p&gt;获取链接的方式可以通过xpath抓取，把抓取的连接传给scrapy的Request()方法进行新页面的抓取，并指定抓取信息的处理回调即可。代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;next_page = response.xpath(&amp;quot;//a[@class=&#39;pn-next&#39;]/@href&amp;quot;).get()
if next_page:
    yield scrapy.Request(&amp;quot;https://list.jd.com&amp;quot;+next_page, callback=self.parse)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;抓取项目进行pipeline处理&#34; &gt;
&lt;div&gt;
    &lt;a href=&#34;#%e6%8a%93%e5%8f%96%e9%a1%b9%e7%9b%ae%e8%bf%9b%e8%a1%8cpipeline%e5%a4%84%e7%90%86&#34;&gt;
        #
    &lt;/a&gt;
    抓取项目进行pipeline处理
&lt;/div&gt;
&lt;/h2&gt;
&lt;p&gt;每一条被爬取好的信息条目会发给pipeline模块进行处理，因此pipeline可以对数据做很多后期的处理工作，包括但不限于：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;清洗抓起数据&lt;/li&gt;
&lt;li&gt;验证抓取的数据&lt;/li&gt;
&lt;li&gt;去重&lt;/li&gt;
&lt;li&gt;存储数据&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这次实践主要用pipeline进行数据的存储处理。默认情况下scrapy使用自带的pipeline进行处理，如果需要进行特殊处理则需要对pipeline进行配置。配置文件是crawler/settings.py。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# Configure item pipelines
# See http://scrapy.readthedocs.org/en/latest/topics/item-pipeline.html
ITEM_PIPELINES = {
    &#39;crawler.pipelines.CrawlerPipeline&#39;: 300,
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;pipeline的配置通过ITEM_PIPELINES完成，可以指定多个pipeline，这样一个pipeline处理完之后可以交给后面的pipeline处理。每一个pipeline条目有一个0-1000之间的整数参数，这个参数指定了pipeline的执行顺序。&lt;/p&gt;
&lt;p&gt;配置好pipeline之后可以在crawler/pipelines.py中编写代码进行存储处理。默认生成的代码中只包含process_item()方法，但对于需要打开文件或者数据库的场景处理会不太方便，我们可以增加open_spider()和close_spider()方法进行处理，比如&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class CrawlerPipeline(object):
    def open_spider(self, spider):
        self.file = open(&#39;result.json&#39;, &#39;w&#39;)

    def close_spider(self, spider):
        self.file.close()

    def process_item(self, item, spider):
        line = json.dumps(dict(item)).decode(&amp;quot;unicode_escape&amp;quot;).encode(&#39;utf-8&#39;) + &#39;\n&#39;
        self.file.write(line)
        return item
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;编码问题&#34; &gt;
&lt;div&gt;
    &lt;a href=&#34;#%e7%bc%96%e7%a0%81%e9%97%ae%e9%a2%98&#34;&gt;
        #
    &lt;/a&gt;
    编码问题
&lt;/div&gt;
&lt;/h2&gt;
&lt;p&gt;前面的process_item()方法中有一行处理编码的代码需要解释一下。在用下面这行代码不进行编码处理的情况下如果直接存储json.dumps()的结果时会存储成人类不能直接阅读的内容。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;line = json.dumps(dict(item)) + &#39;\n&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如下存储的其中一个条目，会发现&amp;quot;name&amp;quot;变成了&amp;rdquo;\uXXXX\uXXXX&amp;quot;的字符串。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{&amp;quot;sku&amp;quot;: &amp;quot;10391738071&amp;quot;, &amp;quot;category&amp;quot;: &amp;quot;3128&amp;quot;, &amp;quot;vendor&amp;quot;: &amp;quot;138857&amp;quot;, &amp;quot;name&amp;quot;: &amp;quot;\u98de\u5229\u6d66\uff08PHILIPS\uff09\u51c0\u6c34\u5668 WP4170/00\u7eaf\u6c34\u673a+WP4100/00\u524d\u7f6e\u8fc7\u6ee4\u5668\u5957\u88c5&amp;quot;, &amp;quot;price&amp;quot;: 4699.0,            &amp;quot;comments&amp;quot;: 4}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;原因是因为json.dumps()对于中文字符的处理会进行escape处理，为了存储需要首先进行unescape，就是进行decode(&amp;ldquo;unicode_escape&amp;rdquo;)。处理后的结果变成了utf-8编码，需要注意的是这还不够。如果这行代码写成下面的形式，则会发现些文件的时候无法写入文件。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;line = json.dumps(dict(item)).decode(&amp;quot;unicode_escape&amp;quot;) + &#39;\n&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;产生的错误发生在file.write()中：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;UnicodeEncodeError: &#39;ascii&#39; codec can&#39;t encode characters in position 71-72: ordinal not in range(128)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这是因为直接写入文件时write()会认为所有的数据都是ascii码，但中文情况下显然是不成立的。因此需要对数据进行encode()，参照下面的代码写就没有问题了：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;line = json.dumps(dict(item)).decode(&amp;quot;unicode_escape&amp;quot;).encode(&#39;utf-8&#39;) + &#39;\n&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注，有写地方会用sys.setdefaultencoding(&amp;lsquo;utf-8&amp;rsquo;)来进行处理，但是不是万不得已并不推荐这种直接改变全局环境的做法，有可能会让程序产生意料不到的情况。&lt;/p&gt;
&lt;h1 id=&#34;数据分析&#34; &gt;
&lt;div&gt;
    &lt;a href=&#34;#%e6%95%b0%e6%8d%ae%e5%88%86%e6%9e%90&#34;&gt;
        ##
    &lt;/a&gt;
    数据分析
&lt;/div&gt;
&lt;/h1&gt;
&lt;p&gt;这次抓取数据主要是分析在各个价格区间的产品用户使用情况，因此可以通过柱状图来展示。横坐标表示价格，用100元为一个区间进行统计。纵坐标显示在这100元的价格范围内的用户评论数量。&lt;/p&gt;
&lt;p&gt;画图使用matplotlib编写，主要的代码逻辑如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;PRICE_UNIT = 100

axis_price = range(PRICE_LOWER_RANGE, PRICE_UPPER_RANGE, PRICE_UNIT)
axis_comment = [0] * len(axis_price)

for item in get_all_sku(category=category):
    idx = int(item.price/PRICE_UNIT)
    
    # 当超过统计价格的上限区间后将结果合并到最高价格范围中
    if idx &amp;gt;= len(axis_price):
        axis_comment[-1] += item.comment
    else:
        axis_comment[idx] += item.comment

width=0.8*PRICE_UNIT
plt.bar(axis_price, axis_comment, width, color=&#39;blue&#39;, align=&#39;edge&#39;)
plt.show()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;绘制结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://singleye-public-read.oss-cn-shanghai.aliyuncs.com/singleye.net/static/2017/08/scrapy/scrapy-005.png?x-oss-process=style/png2jpg&#34; alt=&#34;绘图&#34;&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>nmap NSE脚本中host/port的内容</title>
      <link>/2017/06/nmap-nse%E8%84%9A%E6%9C%AC%E4%B8%ADhost/port%E7%9A%84%E5%86%85%E5%AE%B9/</link>
      <pubDate>Sun, 04 Jun 2017 21:12:03 +0800</pubDate>
      <author>**Email:** [singleye512@gmail.com](mailto:singleye512@gmail.com) (singleye)</author>
      <guid>/2017/06/nmap-nse%E8%84%9A%E6%9C%AC%E4%B8%ADhost/port%E7%9A%84%E5%86%85%E5%AE%B9/</guid>
      <description>&lt;p&gt;周末写了一个简单的nmap的NSE脚本，其中使用了nmap API中的host,port两个变量，数据结构记录。&lt;/p&gt;
&lt;p&gt;Host&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Key&lt;/th&gt;
&lt;th&gt;Value&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;registry&lt;/td&gt;
&lt;td&gt;table: 0x7feae1dc5080&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;name&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;reason_ttl&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;bin_ip&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ip&lt;/td&gt;
&lt;td&gt;192.168.1.10&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;reason&lt;/td&gt;
&lt;td&gt;user-set&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;interface_mtu&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;times&lt;/td&gt;
&lt;td&gt;table: 0x7feae1d9dbf0&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Key&lt;/th&gt;
&lt;th&gt;Value&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;number&lt;/td&gt;
&lt;td&gt;443&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;reason&lt;/td&gt;
&lt;td&gt;syn-ack&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;version&lt;/td&gt;
&lt;td&gt;table: 0x7feae1dfb720&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;state&lt;/td&gt;
&lt;td&gt;open&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;reason_ttl&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;service&lt;/td&gt;
&lt;td&gt;https&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;protocol&lt;/td&gt;
&lt;td&gt;tcp&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;a href=&#34;https://nmap.org/book/nse-api.html&#34;&gt;https://nmap.org/book/nse-api.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://nmap.org/docs/nmap-mindmap.pdf&#34;&gt;https://nmap.org/docs/nmap-mindmap.pdf&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>如何在CentOS上部署shadowsocks服务</title>
      <link>/2017/05/%E5%A6%82%E4%BD%95%E5%9C%A8centos%E4%B8%8A%E9%83%A8%E7%BD%B2shadowsocks%E6%9C%8D%E5%8A%A1/</link>
      <pubDate>Mon, 01 May 2017 23:39:03 +0800</pubDate>
      <author>**Email:** [singleye512@gmail.com](mailto:singleye512@gmail.com) (singleye)</author>
      <guid>/2017/05/%E5%A6%82%E4%BD%95%E5%9C%A8centos%E4%B8%8A%E9%83%A8%E7%BD%B2shadowsocks%E6%9C%8D%E5%8A%A1/</guid>
      <description>&lt;h1 id=&#34;shadowsocks简单介绍&#34; &gt;
&lt;div&gt;
    &lt;a href=&#34;#shadowsocks%e7%ae%80%e5%8d%95%e4%bb%8b%e7%bb%8d&#34;&gt;
        ##
    &lt;/a&gt;
    shadowsocks简单介绍
&lt;/div&gt;
&lt;/h1&gt;
&lt;p&gt;shadowsocks是目前较流行的一种科学上网服务。他的工作原理也比较简单，shadowsocks本质上是socks5代理技术，然而架构方式上将单服务节点拆分成两个子服务：SS Local和SS Server。&lt;/p&gt;
&lt;p&gt;工作过程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当本地请求端需要访问时首先将请求发送至本地SS Local服务&lt;/li&gt;
&lt;li&gt;SS Local将数据加密在网络上传输到SS Server，由于信息经过加密不会被GFW提取到特征数据，因此也就翻了墙&lt;/li&gt;
&lt;li&gt;SS Server收到数据后解密并访问真正的远程服务资源&lt;/li&gt;
&lt;li&gt;远程返回数据返回到SS Server&lt;/li&gt;
&lt;li&gt;SS Server将数据加密传输给SS Local&lt;/li&gt;
&lt;li&gt;SS Local收到返回数据解密后发给本地请求端&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;http://singleye-public-read.oss-cn-shanghai.aliyuncs.com/singleye.net/static/2017/05/what-is-shadowsocks.png&#34; alt=&#34;What&amp;rsquo;s shadow socks&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;部署shadow-socks服务-ss-server&#34; &gt;
&lt;div&gt;
    &lt;a href=&#34;#%e9%83%a8%e7%bd%b2shadow-socks%e6%9c%8d%e5%8a%a1-ss-server&#34;&gt;
        ##
    &lt;/a&gt;
    部署shadow socks服务 (SS Server)
&lt;/div&gt;
&lt;/h1&gt;
&lt;h2 id=&#34;安装服务&#34; &gt;
&lt;div&gt;
    &lt;a href=&#34;#%e5%ae%89%e8%a3%85%e6%9c%8d%e5%8a%a1&#34;&gt;
        #
    &lt;/a&gt;
    安装服务
&lt;/div&gt;
&lt;/h2&gt;
&lt;p&gt;shadowsocks服务的部署也极为简单，已经有完善的脚本帮助安装，需要稍微注意下的就是安装过程需要root权限，安装方法如下：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# wget --no-check-certificate -O shadowsocks.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.sh

# sh shadowsocks.sh
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;配置服务&#34; &gt;
&lt;div&gt;
    &lt;a href=&#34;#%e9%85%8d%e7%bd%ae%e6%9c%8d%e5%8a%a1&#34;&gt;
        #
    &lt;/a&gt;
    配置服务
&lt;/div&gt;
&lt;/h2&gt;
&lt;p&gt;shadowsocks的配置文件是&amp;rsquo;/etc/shadowsocks.json&amp;rsquo;，一个简单的配置文件的写法可以参考这个例子。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# cat /etc/shadowsocks.json
{
    &amp;#34;server&amp;#34;:&amp;#34;0.0.0.0&amp;#34;,
    &amp;#34;port_password&amp;#34;:{
        &amp;#34;8989&amp;#34;:&amp;#34;password1&amp;#34;,    &amp;lt;--- 第一个服务端口及访问密码
        &amp;#34;8990&amp;#34;:&amp;#34;password2&amp;#34;     &amp;lt;--- 多个服务端口指定方法
    },
    &amp;#34;timeout&amp;#34;:300,
    &amp;#34;method&amp;#34;:&amp;#34;aes-256-cfb&amp;#34;,    &amp;lt;--- 注意这个加密方式，配置SS Local需要使用
    &amp;#34;fast_open&amp;#34;:false,
    &amp;#34;workers&amp;#34;:2
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;多数情况下一个端口就可以满足使用了，这个例子中提供了多个访问端口的配置方法，具体用法可以根据自己的实际情况配置。&lt;/p&gt;
&lt;h2 id=&#34;启动服务&#34; &gt;
&lt;div&gt;
    &lt;a href=&#34;#%e5%90%af%e5%8a%a8%e6%9c%8d%e5%8a%a1&#34;&gt;
        #
    &lt;/a&gt;
    启动服务
&lt;/div&gt;
&lt;/h2&gt;
&lt;p&gt;服务安装过程同时会安装一个启动脚本&amp;rsquo;/etc/init.d/shadowsocks&amp;rsquo;，启动方法也很简单。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# service shadowsocks start
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;为了确保每次系统启动后服务会自动运行最好将服务使用chkconfig进行启用，这样就不必担心系统被运营商或者管理员维护重启后无法使用了。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;chkconfig --add shadowsocks
chkconfig --level 2345 shadowsocks on
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;客户端使用方法ss-local&#34; &gt;
&lt;div&gt;
    &lt;a href=&#34;#%e5%ae%a2%e6%88%b7%e7%ab%af%e4%bd%bf%e7%94%a8%e6%96%b9%e6%b3%95ss-local&#34;&gt;
        ##
    &lt;/a&gt;
    客户端使用方法（SS Local）
&lt;/div&gt;
&lt;/h1&gt;
&lt;p&gt;本人使用的是MBP，先分享一下Mac OS上的使用方法。&lt;/p&gt;
&lt;h2 id=&#34;下载安装ss-local&#34; &gt;
&lt;div&gt;
    &lt;a href=&#34;#%e4%b8%8b%e8%bd%bd%e5%ae%89%e8%a3%85ss-local&#34;&gt;
        #
    &lt;/a&gt;
    下载安装SS Local
&lt;/div&gt;
&lt;/h2&gt;
&lt;p&gt;可以在这里下载&lt;a href=&#34;https://github.com/shadowsocks/ShadowsocksX-NG/releases/&#34;&gt;ShadowsocksX-NG&lt;/a&gt;这个软件，将这个软件安装到应用程序中就可以打开使用了，但首先需要一些设置。&lt;/p&gt;
&lt;h2 id=&#34;配置ss-local&#34; &gt;
&lt;div&gt;
    &lt;a href=&#34;#%e9%85%8d%e7%bd%aess-local&#34;&gt;
        #
    &lt;/a&gt;
    配置SS Local
&lt;/div&gt;
&lt;/h2&gt;
&lt;p&gt;程序运行后可以看到一个小飞机样子的图标，点击后可以看到配置菜单。&lt;/p&gt;
&lt;h3 id=&#34;第一步打开配置界面&#34; &gt;
&lt;div&gt;
    &lt;a href=&#34;#%e7%ac%ac%e4%b8%80%e6%ad%a5%e6%89%93%e5%bc%80%e9%85%8d%e7%bd%ae%e7%95%8c%e9%9d%a2&#34;&gt;
        ##
    &lt;/a&gt;
    第一步：打开配置界面
&lt;/div&gt;
&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;http://singleye-public-read.oss-cn-shanghai.aliyuncs.com/singleye.net/static/2017/05/shadowsocks-NG-icon.png&#34; alt=&#34;Step1&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;第二步配置ss-local连接的ss-server服务器&#34; &gt;
&lt;div&gt;
    &lt;a href=&#34;#%e7%ac%ac%e4%ba%8c%e6%ad%a5%e9%85%8d%e7%bd%aess-local%e8%bf%9e%e6%8e%a5%e7%9a%84ss-server%e6%9c%8d%e5%8a%a1%e5%99%a8&#34;&gt;
        ##
    &lt;/a&gt;
    第二步：配置SS Local连接的SS Server服务器
&lt;/div&gt;
&lt;/h3&gt;
&lt;p&gt;点击“服务器设置”&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://singleye-public-read.oss-cn-shanghai.aliyuncs.com/singleye.net/static/2017/05/shadowsocks-NG-server-1.png&#34; alt=&#34;Step2.1&#34;&gt;&lt;/p&gt;
&lt;p&gt;将配置好的服务填入其中，注意的是“地址”／“端口号”／“加密方法”／“密码”信息需要与SS Server服务端的设置匹配。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://singleye-public-read.oss-cn-shanghai.aliyuncs.com/singleye.net/static/2017/05/shadowsocks-NG-server-2.png&#34; alt=&#34;Step2.2&#34;&gt;&lt;/p&gt;
&lt;p&gt;配置完成后记得在服务器列表中选择刚刚配置好的那项。&lt;/p&gt;
&lt;h3 id=&#34;第三步设置高级服务&#34; &gt;
&lt;div&gt;
    &lt;a href=&#34;#%e7%ac%ac%e4%b8%89%e6%ad%a5%e8%ae%be%e7%bd%ae%e9%ab%98%e7%ba%a7%e6%9c%8d%e5%8a%a1&#34;&gt;
        ##
    &lt;/a&gt;
    第三步：设置“高级服务”
&lt;/div&gt;
&lt;/h3&gt;
&lt;p&gt;国内用户最好指定&amp;quot;GFW LIST URL&amp;quot;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;http://singleye-public-read.oss-cn-shanghai.aliyuncs.com/singleye.net/static/2017/05/shadowsocks-NG-advanced.png&#34; alt=&#34;Step3&#34;&gt;&lt;/p&gt;
&lt;p&gt;注意，这里有一个&amp;quot;Local PAC Listen Port&amp;quot;信息，这个配置需要在下面一步使用。&lt;/p&gt;
&lt;h3 id=&#34;第四步设置本地代理方式&#34; &gt;
&lt;div&gt;
    &lt;a href=&#34;#%e7%ac%ac%e5%9b%9b%e6%ad%a5%e8%ae%be%e7%bd%ae%e6%9c%ac%e5%9c%b0%e4%bb%a3%e7%90%86%e6%96%b9%e5%bc%8f&#34;&gt;
        ##
    &lt;/a&gt;
    第四步：设置本地代理方式
&lt;/div&gt;
&lt;/h3&gt;
&lt;p&gt;设置本地代理方式之前最好先将GFW list更新一下&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://singleye-public-read.oss-cn-shanghai.aliyuncs.com/singleye.net/static/2017/05/shadowsocks-NG-gfw-update.png&#34; alt=&#34;Step4.1&#34;&gt;&lt;/p&gt;
&lt;p&gt;打开“系统偏好设置”-&amp;gt;“网络”-&amp;gt;“高级”-&amp;gt;“代理”，勾选“自动代理配置”，在URL中输入：http://127.0.0.1:8090/proxy.pac&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://singleye-public-read.oss-cn-shanghai.aliyuncs.com/singleye.net/static/2017/05/shadowsocks-NG-local-pac.png&#34; alt=&#34;Step4.2&#34;&gt;&lt;/p&gt;
&lt;p&gt;完成这个设置后就已经可以进行科学上网了，系统访问GFW屏蔽的服务时就会使用配置好的代理服务器。&lt;/p&gt;
&lt;h1 id=&#34;使用kcptun加速&#34; &gt;
&lt;div&gt;
    &lt;a href=&#34;#%e4%bd%bf%e7%94%a8kcptun%e5%8a%a0%e9%80%9f&#34;&gt;
        ##
    &lt;/a&gt;
    使用kcptun加速
&lt;/div&gt;
&lt;/h1&gt;
&lt;p&gt;有些时候shadowsocks搭建的主服务器在国外机房中的延迟较大，这样会影响访问速度，这时可以使用一些手段为访问加速，比如&amp;quot;kcptun&amp;quot;。&lt;/p&gt;
&lt;p&gt;TBC&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>阿里云ECS EIP服务进行IPv6改造的方法</title>
      <link>/2017/01/%E9%98%BF%E9%87%8C%E4%BA%91ecs-eip%E6%9C%8D%E5%8A%A1%E8%BF%9B%E8%A1%8Cipv6%E6%94%B9%E9%80%A0%E7%9A%84%E6%96%B9%E6%B3%95/</link>
      <pubDate>Wed, 18 Jan 2017 18:56:51 +0800</pubDate>
      <author>**Email:** [singleye512@gmail.com](mailto:singleye512@gmail.com) (singleye)</author>
      <guid>/2017/01/%E9%98%BF%E9%87%8C%E4%BA%91ecs-eip%E6%9C%8D%E5%8A%A1%E8%BF%9B%E8%A1%8Cipv6%E6%94%B9%E9%80%A0%E7%9A%84%E6%96%B9%E6%B3%95/</guid>
      <description>&lt;p&gt;最近团队开发的APP提交到苹果APP store时被拒了，原因是不支持IPv6的访问。原来苹果App store从2016年6月开始强制新上线APP支持IPv6网络，但由于IPv6基础设施在国内的推广非常缓慢，因此导致了该问题。&lt;/p&gt;
&lt;h1 id=&#34;ipv6介绍&#34; &gt;
&lt;div&gt;
    &lt;a href=&#34;#ipv6%e4%bb%8b%e7%bb%8d&#34;&gt;
        ##
    &lt;/a&gt;
    IPv6介绍
&lt;/div&gt;
&lt;/h1&gt;
&lt;p&gt;为了理解IPv6需要先了解其产生的原因，就是IPv4地址资源的问题。IPv4的网络使用32位的地址空间（XX.XX.XX.XX），因此最大支持的数量是4,294,967,296（2^32个），其中还有1800多万个&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E4%B8%93%E7%94%A8%E7%BD%91%E7%BB%9C&#34;&gt;私有地址&lt;/a&gt;和2.7亿个&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E5%A4%9A%E6%92%AD&#34;&gt;多播地址&lt;/a&gt;。互联网的发展显然超出了普通的32位地址空间的容量，IPv6地址使用128位的地址空间，这意味着几乎取之不尽的地址空间。另外IPv6比IPv4还进行了很多的改进与扩充。&lt;/p&gt;
&lt;h2 id=&#34;ipv6地址&#34; &gt;
&lt;div&gt;
    &lt;a href=&#34;#ipv6%e5%9c%b0%e5%9d%80&#34;&gt;
        #
    &lt;/a&gt;
    IPv6地址
&lt;/div&gt;
&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;冒分16进制表示法（XXXX:XXXX:XXXX:XXXX:XXXX:XXXX:XXXX:XXXX），每个部分中的0可以省略。比如：2001:0DB8:0000:0023:0008:0800:200C:417A 可以缩写为2001:DB8:0:23:8:800:200C:417A&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;0位压缩。如果地址中包含很多连续的0，可以把0压缩为&amp;quot;::&amp;quot;，并且&amp;quot;::&amp;ldquo;只能出现1次。
比如 FF01:0:0:0:0:0:0:1101 可以缩略为 FF01::1101&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;内嵌IPv4地址表示法。为了实现IPv4-IPv6互通，IPv4地址会嵌入IPv6地址中，此时地址常表示为：X:X:X:X:X:X:d.d.d.d，前96b采用冒分十六进制表示，而最后32b地址则使用IPv4的点分十进制表示，例如::192.168.0.1与::FFFF:192.168.0.1就是两个典型的例子，注意在前96b中，压缩0位的方法依旧适用。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;ipv6地址分类&#34; &gt;
&lt;div&gt;
    &lt;a href=&#34;#ipv6%e5%9c%b0%e5%9d%80%e5%88%86%e7%b1%bb&#34;&gt;
        #
    &lt;/a&gt;
    IPv6地址分类
&lt;/div&gt;
&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;地址类型&lt;/th&gt;
&lt;th&gt;IPv4&lt;/th&gt;
&lt;th&gt;IPv6&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;单播(unicast)&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;组播(multicast)&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;任播(anycast)&lt;/td&gt;
&lt;td&gt;No&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;广播&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;td&gt;No (通过组播来达到类似目的)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;IPv6的地址类型通过地址的前缀进行区别&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;IPv6地址类型&lt;/th&gt;
&lt;th&gt;前缀标识&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Loopback (unicast)&lt;/td&gt;
&lt;td&gt;::1/128&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Link local (unicast)&lt;/td&gt;
&lt;td&gt;FE80::/10&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Site local (unicast)&lt;/td&gt;
&lt;td&gt;FEC0::/10&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Global (unicast)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;multicast&lt;/td&gt;
&lt;td&gt;FF00::/8&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;anycast&lt;/td&gt;
&lt;td&gt;从单播地址空间中分配&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;ipv4-vs-ipv6&#34; &gt;
&lt;div&gt;
    &lt;a href=&#34;#ipv4-vs-ipv6&#34;&gt;
        #
    &lt;/a&gt;
    IPv4 vs IPv6
&lt;/div&gt;
&lt;/h2&gt;
&lt;p&gt;IPv6比IPv4的优势：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;IPv6具有更大的地址空间。IPv4中规定IP地址长度为32，最大地址个数为2^32；而IPv6中IP地址的长度为128，即最大地址个数为2^128。与32位地址空间相比，其地址空间增加了2^128-2^32个。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IPv6使用更小的路由表。IPv6的地址分配一开始就遵循聚类（Aggregation）的原则，这使得路由器能在路由表中用一条记录（Entry）表示一片子网，大大减小了路由器中路由表的长度，提高了路由器转发数据包的速度。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IPv6增加了增强的组播（Multicast）支持以及对流的控制（Flow Control），这使得网络上的多媒体应用有了长足发展的机会，为服务质量（QoS，Quality of Service）控制提供了良好的网络平台。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IPv6加入了对自动配置（Auto Configuration）的支持。这是对DHCP协议的改进和扩展，使得网络（尤其是局域网）的管理更加方便和快捷。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IPv6具有更高的安全性。在使用IPv6网络中用户可以对网络层的数据进行加密并对IP报文进行校验，在IPV6中的加密与鉴别选项提供了分组的保密性与完整性。极大的增强了网络的安全性。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;允许扩充。如果新的技术或应用需要时，IPV6允许协议进行扩充。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;更好的头部格式。IPV6使用新的头部格式，其选项与基本头部分开，如果需要，可将选项插入到基本头部与上层数据之间。这就简化和加速了路由选择过程，因为大多数的选项不需要由路由选择。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;新的选项。IPV6有一些新的选项来实现附加的功能[14]  。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;阿里ecs-eip-服务ipv6支持方法&#34; &gt;
&lt;div&gt;
    &lt;a href=&#34;#%e9%98%bf%e9%87%8cecs-eip-%e6%9c%8d%e5%8a%a1ipv6%e6%94%af%e6%8c%81%e6%96%b9%e6%b3%95&#34;&gt;
        ##
    &lt;/a&gt;
    阿里ECS EIP 服务IPv6支持方法
&lt;/div&gt;
&lt;/h1&gt;
&lt;h2 id=&#34;6in4隧道方式&#34; &gt;
&lt;div&gt;
    &lt;a href=&#34;#6in4%e9%9a%a7%e9%81%93%e6%96%b9%e5%bc%8f&#34;&gt;
        #
    &lt;/a&gt;
    6in4隧道方式
&lt;/div&gt;
&lt;/h2&gt;
&lt;p&gt;6in4的方法是将IPv6的数据包包裹在IPv4的数据包中在IPv4的网络上传输，并通过IPv4/IPv6的网络交界处部署的tunnel broker进行疯转转发，基本工作原理如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;IPv6网络上的客户端对服务进行访问时发送IPv6数据包，数据包到达tunnel
broker的服务器端，broker将数据包进行IPv4的封装通过隧道发送到你的IPv4服务器端，在隧道的另一端进行IPv6数据包的应用层处理。&lt;/li&gt;
&lt;li&gt;你的服务器收到数据包进行应用层处理后将相应数据包进行IPv6封装，再通过隧道包裹成IPv4的数据报文进行隧道传输，当数据包抵达IPv4/IPv6的网络交界处的tunnel broker时，tunnel broker将IPv6的包解析出来在IPv6的网络上进行传递到达IPv6的客户端。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面我们以6in4的方式对阿里云ECS服务器上使用EIP的服务进行IPv6改造。&lt;/p&gt;
&lt;h3 id=&#34;1-创建tunnel&#34; &gt;
&lt;div&gt;
    &lt;a href=&#34;#1-%e5%88%9b%e5%bb%batunnel&#34;&gt;
        ##
    &lt;/a&gt;
    1. 创建tunnel
&lt;/div&gt;
&lt;/h3&gt;
&lt;p&gt;到&lt;a href=&#34;https://www.tunnelbroker.net&#34;&gt;tunnelbroker&lt;/a&gt;注册账号，并且创建一个新的常规(Regular) tunnel。创建时候需要在&amp;rsquo;IPv4 Endpoint&amp;rsquo;栏填入服务器的公网IPv4地址，并在&amp;rsquo;Available Tunnel Servers&amp;rsquo;中选择一个适合自己的服务器区域，过程如下图：
&lt;img src=&#34;http://singleye-public-read.oss-cn-shanghai.aliyuncs.com/singleye.net/static/2017/01/create_tunnel.jpg&#34; alt=&#34;创建tunnel&#34;&gt;&lt;/p&gt;
&lt;p&gt;创建完成后的tunnel包含了几个重要的信息：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Server IPv4 Address: 这个是tunnel服务端的IPv4地址，创建tunnel的时候需要用到。&lt;/li&gt;
&lt;li&gt;Server IPv6 Address: 这个是tunnel的服务端IPv6地址。&lt;/li&gt;
&lt;li&gt;Client IPv4 Address: 这个是tunnel客户端的IPv4地址。&lt;/li&gt;
&lt;li&gt;Client IPv6 Address: 这个地址需要设置在CentOS服务器的tunnel上面，也是后面DNS服务器需要设置的AAAA记录对应的地址。
&lt;img src=&#34;http://singleye-public-read.oss-cn-shanghai.aliyuncs.com/singleye.net/static/2017/01/tunnel_detail.jpg&#34; alt=&#34;tunnel详情&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2-解除阿里云主机ipv6限制&#34; &gt;
&lt;div&gt;
    &lt;a href=&#34;#2-%e8%a7%a3%e9%99%a4%e9%98%bf%e9%87%8c%e4%ba%91%e4%b8%bb%e6%9c%baipv6%e9%99%90%e5%88%b6&#34;&gt;
        ##
    &lt;/a&gt;
    2. 解除阿里云主机IPv6限制
&lt;/div&gt;
&lt;/h3&gt;
&lt;p&gt;阿里云的CentOS主机默认状态下是把IPv6给禁掉的，可以使用下面的脚本先把系统的IPv6功能打开。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 1&lt;/span&gt;&lt;span&gt;&lt;span style=&#34;color:#099&#34;&gt;#!/bin/sh
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 2&lt;/span&gt;&lt;span&gt;&lt;span style=&#34;color:#099&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 3&lt;/span&gt;&lt;span&gt;mkdir ipv6
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 4&lt;/span&gt;&lt;span&gt;mv /etc/modprobe.d/disable_ipv6.conf ipv6/
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 5&lt;/span&gt;&lt;span&gt;modprobe ipv6
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 6&lt;/span&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 7&lt;/span&gt;&lt;span&gt;cp /etc/sysctl.conf ipv6/
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 8&lt;/span&gt;&lt;span&gt;cat /etc/sysctl.conf | sed -e &lt;span style=&#34;color:#c30&#34;&gt;&amp;#39;s/disable_ipv6 = 1/disable_ipv6 = 0/&amp;#39;&lt;/span&gt; &amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 9&lt;/span&gt;&lt;span&gt;/etc/.sysctl.conf.bak
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;10&lt;/span&gt;&lt;span&gt;mv -f /etc/.sysctl.conf.bak /etc/sysctl.conf
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;11&lt;/span&gt;&lt;span&gt;sysctl -p /etc/sysctl.conf&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;完成上面配置后可以用&amp;rsquo;ifconfig&amp;rsquo;检验一下网络接口，如果出现&amp;rsquo;inet6&amp;rsquo;类型的信息说明配置已经生效。&lt;/p&gt;
&lt;h3 id=&#34;3-配置centos服务器端tunnel&#34; &gt;
&lt;div&gt;
    &lt;a href=&#34;#3-%e9%85%8d%e7%bd%aecentos%e6%9c%8d%e5%8a%a1%e5%99%a8%e7%ab%aftunnel&#34;&gt;
        ##
    &lt;/a&gt;
    3. 配置CentOS服务器端tunnel
&lt;/div&gt;
&lt;/h3&gt;
&lt;p&gt;这里顺带介绍一下Linux支持的几种隧道：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;IP隧道：通过将IPv4数据包封装进另一个IPv4数据包中进行发送，实现两个互不连通的IP网络之间的连接。但是不能通过隧道进行广播或者IPv6数据包的发送。&lt;/li&gt;
&lt;li&gt;SIT隧道：将IPv6数据包封装进IPv4数据包中，对应6in4的场景。&lt;/li&gt;
&lt;li&gt;GRE隧道：最初是由cisco开发的隧道协议，能够进行多播及IPv6数据包的发送。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这次主要介绍&amp;quot;SIT&amp;quot;隧道的方案。现在需要用到上面创建tunnel时的&amp;rsquo;Server IPv4 Address&amp;rsquo;/&amp;lsquo;Client IPv4 Address&amp;rsquo;/&amp;lsquo;Client IPv6 Address&amp;rsquo;，在你的ECS主机上面运行下面的命令：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;1&lt;/span&gt;&lt;span&gt;ip tunnel add he-ipv6 mode sit remote &lt;span style=&#34;color:#555&#34;&gt;[&lt;/span&gt;Server IPv4 Address&lt;span style=&#34;color:#555&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#366&#34;&gt;local&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;[&lt;/span&gt;Client IPv4 Address&lt;span style=&#34;color:#555&#34;&gt;]&lt;/span&gt; ttl &lt;span style=&#34;color:#f60&#34;&gt;255&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;2&lt;/span&gt;&lt;span&gt;ip link &lt;span style=&#34;color:#366&#34;&gt;set&lt;/span&gt; he-ipv6 up
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;3&lt;/span&gt;&lt;span&gt;ip addr add &lt;span style=&#34;color:#555&#34;&gt;[&lt;/span&gt;Client IPv6 Address&lt;span style=&#34;color:#555&#34;&gt;]&lt;/span&gt;/64 dev he-ipv6
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;4&lt;/span&gt;&lt;span&gt;ip route add ::/0 dev he-ipv6
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;5&lt;/span&gt;&lt;span&gt;ip -f inet6 addr&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;完成这一步后已经可以对&amp;rsquo;[Client IPv6 Address]&amp;lsquo;进行访问了，可以通过&amp;rsquo;ping6&amp;rsquo;或者&amp;rsquo;curl&amp;rsquo;进行验证。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;1&lt;/span&gt;&lt;span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;# ping6 [Client IPv6 Address]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;2&lt;/span&gt;&lt;span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;# curl --globoff -6 [Client IPv6 Address]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&#34;4-设置dns-aaaa记录&#34; &gt;
&lt;div&gt;
    &lt;a href=&#34;#4-%e8%ae%be%e7%bd%aedns-aaaa%e8%ae%b0%e5%bd%95&#34;&gt;
        ##
    &lt;/a&gt;
    4. 设置DNS AAAA记录
&lt;/div&gt;
&lt;/h3&gt;
&lt;p&gt;大家熟悉的A记录是DNS中IPv4的对应地址，相应的IPv6地址叫AAAA记录。设置成功后就可以直接用DNS进行访问了。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;1&lt;/span&gt;&lt;span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;# ping6 [Client IPv6 DNS name]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;2&lt;/span&gt;&lt;span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;# curl --globoff -6 [Client IPv6 DNS name]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id=&#34;附录&#34; &gt;
&lt;div&gt;
    &lt;a href=&#34;#%e9%99%84%e5%bd%95&#34;&gt;
        ##
    &lt;/a&gt;
    附录
&lt;/div&gt;
&lt;/h1&gt;
&lt;h2 id=&#34;ipv4私有地址&#34; &gt;
&lt;div&gt;
    &lt;a href=&#34;#ipv4%e7%a7%81%e6%9c%89%e5%9c%b0%e5%9d%80&#34;&gt;
        #
    &lt;/a&gt;
    IPv4私有地址
&lt;/div&gt;
&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;RFC1918 规定区块名&lt;/th&gt;
&lt;th&gt;IP地址区段&lt;/th&gt;
&lt;th&gt;IP数量&lt;/th&gt;
&lt;th&gt;分类网络说明&lt;/th&gt;
&lt;th&gt;最大CIDR区块（子网络遮罩）&lt;/th&gt;
&lt;th&gt;主机端位长&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;24位区块&lt;/td&gt;
&lt;td&gt;10.0.0.0 – 10.255.255.255&lt;/td&gt;
&lt;td&gt;16,777,216&lt;/td&gt;
&lt;td&gt;单个A类网络&lt;/td&gt;
&lt;td&gt;10.0.0.0/8(255.0.0.0)&lt;/td&gt;
&lt;td&gt;24位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Shared Address Space&lt;/td&gt;
&lt;td&gt;100.64.0.0 - 100.127.255.255&lt;/td&gt;
&lt;td&gt;4,194,304&lt;/td&gt;
&lt;td&gt;64个连续B类网络&lt;/td&gt;
&lt;td&gt;100.64.0.0/10 (255.192.0.0)&lt;/td&gt;
&lt;td&gt;22位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;20位区块&lt;/td&gt;
&lt;td&gt;172.16.0.0 – 172.31.255.255&lt;/td&gt;
&lt;td&gt;1,048,576&lt;/td&gt;
&lt;td&gt;16个连续B类网络&lt;/td&gt;
&lt;td&gt;172.16.0.0/12(255.240.0.0)&lt;/td&gt;
&lt;td&gt;20位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;16位区块&lt;/td&gt;
&lt;td&gt;192.168.0.0 – 192.168.255.255&lt;/td&gt;
&lt;td&gt;65,536&lt;/td&gt;
&lt;td&gt;256个连续C类网络&lt;/td&gt;
&lt;td&gt;192.168.0.0/16(255.255.0.0)&lt;/td&gt;
&lt;td&gt;16位&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;参考资料&#34; &gt;
&lt;div&gt;
    &lt;a href=&#34;#%e5%8f%82%e8%80%83%e8%b5%84%e6%96%99&#34;&gt;
        ##
    &lt;/a&gt;
    参考资料
&lt;/div&gt;
&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/IPv6&#34;&gt;https://zh.wikipedia.org/wiki/IPv6&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://baike.baidu.com/item/IPv6&#34;&gt;http://baike.baidu.com/item/IPv6&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://test-ipv6.com/faq_6to4.html&#34;&gt;http://test-ipv6.com/faq_6to4.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>搭建SoftEther VPN 服务</title>
      <link>/2017/01/%E6%90%AD%E5%BB%BAsoftether-vpn-%E6%9C%8D%E5%8A%A1/</link>
      <pubDate>Tue, 10 Jan 2017 15:22:39 +0000</pubDate>
      <author>**Email:** [singleye512@gmail.com](mailto:singleye512@gmail.com) (singleye)</author>
      <guid>/2017/01/%E6%90%AD%E5%BB%BAsoftether-vpn-%E6%9C%8D%E5%8A%A1/</guid>
      <description>&lt;p&gt;最近在公司内部架了台服务器给团队的同学们使用，可是在公司外面的时候就没办法再继续访问上面的资源了实在不太方便，虽然利用公司路由器的可以将服务器端口映射出去，但这样做只能访问部分资源，还是搭建一套VPN服务器更加适合所有人的需求。&lt;/p&gt;
&lt;p&gt;研究了一下PPP/L2TP，但PPP已经在iOS设备上见不到了，L2TP又对CentOS 7.3支持不友好，后来找到了SoftEther，发现不仅协议支持全面而且支持命令行／图形界面的管理工具，使用和管理都很方便。&lt;/p&gt;
&lt;h1 id=&#34;搭建方法&#34; &gt;
&lt;div&gt;
    &lt;a href=&#34;#%e6%90%ad%e5%bb%ba%e6%96%b9%e6%b3%95&#34;&gt;
        ##
    &lt;/a&gt;
    搭建方法
&lt;/div&gt;
&lt;/h1&gt;
&lt;h2 id=&#34;通过local-bridge的方式访问远程网络&#34; &gt;
&lt;div&gt;
    &lt;a href=&#34;#%e9%80%9a%e8%bf%87local-bridge%e7%9a%84%e6%96%b9%e5%bc%8f%e8%ae%bf%e9%97%ae%e8%bf%9c%e7%a8%8b%e7%bd%91%e7%bb%9c&#34;&gt;
        #
    &lt;/a&gt;
    通过Local bridge的方式访问远程网络
&lt;/div&gt;
&lt;/h2&gt;
&lt;p&gt;具体过程可以参照&lt;a href=&#34;https://www.softether.org/4-docs/2-howto/1.VPN_for_On-premise/2.Remote_Access_VPN_to_LAN&#34;&gt;官方文档&lt;/a&gt;，这种方法也是我最开始使用的方法，但搭建好之后发现这种连接的设备无法访问搭建VPN的服务器本身，但是我们这台服务器上提供了需要大家访问的资源，因此这对与我们公司来说是无法接受的。原因也可以理解，因为Linux不允许访问Local bridge网络接口对应的IP。具体可以参考官方文档的&lt;a href=&#34;https://www.softether.org/4-docs/1-manual/3._SoftEther_VPN_Server_Manual/3.6_Local_Bridges&#34;&gt;解释&lt;/a&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Limitations within the Linux or UNIX operating system prevent communication with IP addresses assigned to the network adapter locally bridged from the VPN side (Virtual Hub side). The cause of this restriction lies with OS&amp;rsquo;s internal kernel codes rather than with the SoftEther VPN. When wishing to communicate in any form with a UNIX computer used for local bridging from the VPN side (Virtual Hub side), (for instance, when running both the VPN Server / VPN Bridge service &amp;amp; the HTTP Server service and wishing to grant access to the server service from the VPN side as well), prepare and connect a local bridge network adapter and physically connect both it and the existing network adapter to the same segment (as explained in 3.6 Local Bridges, it is recommended to prepare a network adapter for exclusive use in local bridging for this and other situations).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;通过tap网络接口&#34; &gt;
&lt;div&gt;
    &lt;a href=&#34;#%e9%80%9a%e8%bf%87tap%e7%bd%91%e7%bb%9c%e6%8e%a5%e5%8f%a3&#34;&gt;
        #
    &lt;/a&gt;
    通过tap网络接口
&lt;/div&gt;
&lt;/h2&gt;
&lt;p&gt;后来发现可以通过tap设备来解决访问VPN服务器本身的问题，原理就是创建出一个tap设备并将它桥接到真实设备上。tap设备的配置过程和Local bridge方式基本一致，可以参考下图：
&lt;img src=&#34;https://wordpress.youran.me/wp-content/uploads/2014/12/create-local-bridge.png&#34; alt=&#34;Tap device&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;centos系统设置&#34; &gt;
&lt;div&gt;
    &lt;a href=&#34;#centos%e7%b3%bb%e7%bb%9f%e8%ae%be%e7%bd%ae&#34;&gt;
        #
    &lt;/a&gt;
    CentOS系统设置
&lt;/div&gt;
&lt;/h2&gt;
&lt;p&gt;完成tap设备配置后，在CentOS上还需要完成下面的设置才可以使用：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;防火墙配置，允许VPN服务器的配置和客户连接：
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;1&lt;/span&gt;&lt;span&gt;$ sudo firewall-cmd –zone&lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt;public –add-port&lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt;500/udp –permanent
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;2&lt;/span&gt;&lt;span&gt;$ sudo firewall-cmd –zone&lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt;public –add-port&lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt;4500/udp –permanent
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;3&lt;/span&gt;&lt;span&gt;$ sudo firewall-cmd –zone&lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt;public –add-port&lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt;1701/udp –permanent
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;4&lt;/span&gt;&lt;span&gt;$ sudo firewall-cmd –zone&lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt;public –add-port&lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt;443/tcp –permanent
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;5&lt;/span&gt;&lt;span&gt;$ sudo firewall-cmd –reload&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;配置tap device：
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;1&lt;/span&gt;&lt;span&gt;$ sudo brctl addif br0 tap_soft
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;2&lt;/span&gt;&lt;span&gt;$ sudo brctl show
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;3&lt;/span&gt;&lt;span&gt;bridge name bridge id STP enabled interfaces
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;4&lt;/span&gt;&lt;span&gt;br0 8000.00acc3a0fd4d yes p4p2
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;5&lt;/span&gt;&lt;span&gt;tap_soft&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
  </channel>
</rss>
